╔==============================================================================╗
║Name        : Bash commands.txt                                               ║
║Author      : Daniel Silbermann, s090116, Declined#8151 (Discord ID)          ║
║Version     : 2.13.06                                                         ║
║Date        : 29/09-20                                                        ║
║Last Updated: 26/02-22                                                        ║
║Copyright   : Do not alter, this file without permission                      ║
║              For non commercial use only.                                    ║
║Licence     : CC BY-NC-ND                                                     ║
║              https://creativecommons.org/about/cclicenses/                   ║
║Description : A rough guide for new users to understand bash console commmands║
║              Made for students at DTU.                                       ║
║              To be used by the teacher(s) at their discretion.               ║
║Teacher     : Bhupjit Singh - bhsi@dtu.dk                                     ║
╚==============================================================================╝
╔==============================================================================╗
║    Table of contents:                                                        ║
║               - Introduction                                                 ║
║               - Guide info                                                   ║
║               - General tips                                                 ║
║               - Elevated priviledge                                          ║
║               - System Commands                                              ║
║                 * Permission explanation                                     ║
║               - System/User Info                                             ║
║                 * Process details                                            ║
║               - User administration                                          ║
║               - Directory commands                                           ║
║               - Help section                                                 ║
║               - File access, edit, format                                    ║
║               - Packages and installations                                   ║
║               - Networking                                                   ║
║               - VARIABLES                                                    ║
║               - FUNCTIONS-(NOT COMMANDS)                                     ║
║               - Command line shortcuts                                       ║
║               - Hardware                                                     ║
║               - VIM tutorial                                                 ║
║               - Uncategorized                                                ║
║               - References                                                   ║
╚==============================================================================╝
╔==============================================================================╗
║  Advanced topics:                                                            ║
║   Found beneath the last paragraph listed here, is another table of contents.║
║   These sections are setup to go further into depth about a specific complex ║
║   topic, and are not relevant for new users to the command console.          ║
║   It includes specific concepts, detailed info about specific commands, and  ║
║   a list of different relevant tables.                                       ║
╚==============================================================================╝
╔==============================================╗
║                 Introduction                 ║
╚==============================================╝
This document is designed to give you an
introduction to what Linux is, and to become
familiar with the command console.

Linux is the name of a combined group of
Operating Systems, that utilize the UNIX kernel.
It has a modular setup, where you can choose
many aspects to either create your own 'Distro',
or use a preexisting version.

The term 'distro' refers to distribution types.
Distributions are organized based on the 
"Package management system".
There are two primary distribution types
RPM-based, and DEB-based.
RPM uses the .rpm file format, most known
distros are: Red Hat Linux, CentOS, Fedora.
DEB emphasizes 'free software' often referred
to as 'debian type'.
Most known distros are: Ubuntu, Linux Mint, 
Linux Kali.

Because of this distinction, and modular setup,
Some commands may not be natively installed on 
a distro, which means you have to install them
yourself, or the version of a command you have, 
might work slightly differently in your distro
compared to another.

One very strong advantage for choosing Linux
is the powerful setup for creating and managing
servers.

Examples of server types and tools               Description
------------------------------------------------|---------------
Apache                                          : Web server
SAMBA                                           : A tool with multiple server and management option for Linux and Unix
                                                  It allows windows to share files and printers on the Unix host
                                                  It also allows Unix users to access resources shared by Windows systems.
Oracle, MySQL (MariaDB), Mongodb, etc.          : Database

Additional server types.
Mail/FTP/DNS/router/firewall and more           

There is a list of useful abbreviations found in
table 1.0 near the end of the document.

╔==============================================╗
║                  Guide info                  ║
╚==============================================╝
Information about the format of this document

'$ ' is used to emulate a command line,
specifically intended for examples of full
commands.
Notice that '$STUFF' refers to variables.

This will be the max width of this file---------------------------------------------------------------------------------------->|
: Explanation of command
- Command options, or continuations of the
  previous colon (:) explanation.
[empty] is a pseudonym for not entering anything.
[command] refers to commands themselves
[option] refers to '-operator' options.

From this point forward, this format will
primarily be used, with commands to the left,
and a description of said command to the right.

Commands                                         Description
------------------------------------------------|---------------
[Command]                                       : Command description
                                                  Related info
        -[Operator]                             - info about operator

╔==============================================╗
║                 General tips                 ║
╚==============================================╝
Some of the most useful tips for navigating and
using the command console, efficiently.

Commands                                         Description
------------------------------------------------|---------------
Navigate to folder, then type 'bash'            : Open a terminal, which has already navigated to folder
in the address field.                             Requires that Linux subsystem for Windows is activated
                                                  and that a Linux distribution is virtually installed
                                                  i.e. Microsoft store, Ubuntu (LTS version, which stands
                                                  for 'Long Term Support')
cd                                              : Change Directory, '..' to move up a directory
                                                  When inside a directory and you've typed part of the name
                                                  of a file. hit 'tab' to auto fill out the content.
                                                  Double hit 'tab' to see a list of directories.
                                                - Use '$ cd -' to go back to the directory you were just in
                                                - Use '$ cd /' to go to root directory
                                                - Use '$ cd ~' to go to HOME directory
pwd                                             : Print Working directory.
something '>>' filename                         : Append content to file named filename
something '>' filename                          : Overwrite content of file named filename
                                                  These are great options for pasting output into log files,
                                                  when writing and testing C-programs.
[Example]
echo yolo > derpy.txt                           : Overwrites the content of file derpy.txt "yolo"
echo yolo >> derpy.txt                          : Append "yolo" to the content of file derpy.txt

(if intalled)Type 'code .' to open Visual Studio
Code with that folder already being navigated to.

To compile and run C code files
$ gcc -o newfilename someCcodefile.c            : Will compile the file, and save the compiled version in 'newfilename'
$ ./newfilename                                 : Executes the compiled file.

After writing a command, you sometimes write '-'
and then add an operator, such as
$ ls -l -a
This is equivalent to 
$ ls -la
Because using a single '-' means that each 
character is treated as a separate operator.
Some operators requires that they are directly
followed by a piece of information, such as
new filename, port number and similar and must
therefore not be groupd with other operators.
If you use '--' the whole word is supplied
as an argument.
$ ls --help

To terminate access, or close the console, 
use the command 'exit'
$ exit        

If the commands are exceedingly long, use '\' as
a method to break the line, and continue writing
a command on  the following line.

The 'grep' command print lines that match
patterns.
Often used in conjunction with the pipeline
character "|", which forwards the output of a
command to another command.

[Example]
$ grep "some text" myfile.txt                   : Search through myfile looking for "some text" and
                                                  print lines that match.
$ top | grep root                               : Will present the processes related to root.

If you screw up somehow, terminate an active
process with [CTRL + C], i.e. 'htop' or an
infinitely running program.

[CTRL + L]                                      : Clears the bash terminal of text.
[CTRL + U]                                      : Cut beginning of line, cut text to the beginning of the line.

A similar tool in Linux, to 'Task Manager' 
from Windows, are the commands 'top', 'htop', 
and 'ps'.

╔==============================================╗
║              Elevated privilegde             ║
╚==============================================╝
For some commands, you require root access,
this section explains how to acquire that.
Most of these are centered around administrator
tasks, such as managing users, packages, access,
and more.

The prompt symbol for regular users is a dollar
sign ($), the prompt symbol for superuser
is hashtag (#), use this as an indicator
to see if you've got direct root access.
Or if you need to request it, in order to run
a command.

Commands                                         Description
------------------------------------------------|---------------
sudo                                            : Execute a command as another user, 'Super user' to be exact.
                                                  Super user access (creates a timer in the background,
                                                  before requiring a password again)
        --help                                  - See a list of options, and their uses
visudo                                          : visudo edits the sudoers file, which defines the users and groups with
                                                  administrator rights. (Don't mess with unless you know what you're doing)
updatedb                                        - Creates or updates a database used by 'locate(1)'
sudos                                           : Super user access, for extended periods, (generally
                                                  not a good idea unless you know what you're doing)
        -s                                      - Disable the timer, and continue on as the super user
                                                  (WARNING, DON'T FORGET to log out)
        exit                                    - Will terminate the super user access
su                                              : Switch user
        [empty]                                 - Changing to root access ()
        - [empty]                               - Changing to root user, but remains in the current users home directory
        - [Username]                            - will change to other specified user on the username.
        [username]                              - Will switch to other user, but remain in your own home directory
systemctl                                       : Control the systemd system and service Manager
        start                                   - Start a service
        stop                                    - Stop a service
        restart                                 - Restart a service
        status                                  - See status as a whole or of a service
        enable                                  - Enable a service on boot
        disable                                 - Disable a service on boot
journalctl                                      : Query the systemd journal

[Example]
$ sudo apt-get update                           : Update packages, a command that require Root access.
$ systemclt Status                              : Show system status
$ systemclt status [subject]                    : Show detailed information about a currently active [subject]
                                                  followed by most recent log data from the journal.

╔==============================================╗
║                System Commands               ║
╚==============================================╝
Primarily related to altering data within the
OS, such as file permissions, altering processes
and more.

Commands                                         Description
------------------------------------------------|---------------
chmod                                           : Change file mode bits. Permission for files and directories.
                                                  Look at the next paragraph for details regarding bit setup, and numbers
       u+..                                     - 'User' option
       g+..                                     - 'Group' option
       o+..                                     - 'Other' option
        +r [Filename]                           - Makes the file readable
        +w [Filename]                           - Makes the file writeable
        +x [Filename]                           - Makes the file executable
       u+s [Filename]                           - Add setuid bit 
       g+s [Filename]                           - Add setgid bit 
killall                                         : Kill all processes that you have access to, use with care, as you may
                                                  terminate more processes than you intended.
        [a-zA_Z]                                - Terminates any process related to that name
kill                                            : Sends a signal to a process.
                                                  By default, send a SIGKILL signal to a process
       -[SIGNAL]                                - Optional, specify which signal number or signal name, to
                                                  send a specific signal
        [PID/%JOB_SPEC]                         - Which process to kill, JOB_SPEC is for background
                                                  processes, so you may need to look up the PID.
nice                                            : Run a program with modified scheduling priority
                                                  Used for determining the 'nice' value upon process creation.
renice                                          : Alter the 'niceness' priority of a running processes.
gcc                                             : Compile program from c language.
        -o                                      - Output, next argument will be the created filename
whois                                           : shows some whois data about a website or ip
        [ip or website]
        | more/less                             - Displayed using the more or less format

pstree                                          : Display a tree of process
fsck                                            : Check and repair a Linux filesystem
parted                                          : A partition manipulation program
alias                                           : Access to aliases
unalias                                         : Remove an alias
                                                  Remember that if an alias is set in a  configuration file, it will be
                                                  set again when you open another shell.
export                                          : Set the export attribute for variables
                                                  Used for passing variables to child shells.
                                                - If no name is supplied, updates all.
        -p                                      - Display a list of all exported variables
shutdown                                        : Halt, power-off or reboot the machine

[EXAMPLES]
$ chmod 650 [filename]                          : Where 6 is the user, 5 is group, 0 is other
$ chmod 755 [directory]                         : 755 is recommended for directories
$ chmod 744 [filename]                          : 644 is recommended for files. 
$ chmod g+w myfile.txt                          : Allows the group write access to myfile.txt
$ gcc -o [newname] [c-file]                     : General format for compiling C-files
$ gcc -o derp /test_folder/test.c               : Here we navigate into a folder to find the test.c file,
                                                  the 'derp' file, is placed in the current directory
$ alias                                         : Display a list of aliases
$ alias p='pwd ; ls -CF'                        : Create a new alias 'p', which is 2 commands, followed by one another
                                                  For the alias to be saved between shells and sessions, they need to
                                                  stored in the configuration files
$ alias derpyPing='ping -c 100 google.com'      : A relatively simple command to send 100 packages to google, and Then
                                                  generate som statistics to check the connection
$ shutdown -r now                               : Reboot computer now
$ shutdown -h now                               : Halt computer now
$ shutdown -r +10 mins                          : Reboot computer in 10 minutes
$ shutdown -c                                   : Cancel pending shutdown

╔==============================================╗
║           * Permission Explanation           ║
╚==============================================╝
Each file and directory has some metadata, such
as: Group, owner, read, write, executable, 
sticky bit, setuid bit, setgid bit and more.

When you call the 'ls' command with '-l' option
you can see the permissions of the files and
folders located within that directory using a
specific format.

If you use the '-a' option, you also display
hidden files and folders. They're displayed
with a dot (.) in front.

Permission explanation:
https://youtu.be/oxuRxtrO2Ag?t=3490
Set up in relation to separate bits, from left
to right:
r = read                                        : [4] Decimal value #4, == 0x4, == 0b100
w = write                                       : [2] Decimal value #2, == 0x2, == 0b010
x = execute                                     : [1] Decimal value #1, == 0x1, == 0b001

Meaning that:
7 = read, write, execute privilege [111]
6 = read and write privilege       [110]
5 = read and execute privilege     [101]
and so on

-rwxrwxrwx
|||||||||└────────────────────────────────────> : Execute bit, for 'Other'
||||||||└─────────────────────────────────────> : Write bit, for 'Other'
|||||||└──────────────────────────────────────> : Read bit, for 'Other'
||||||└───────────────────────────────────────> : Execute bit, for 'Group'
|||||└────────────────────────────────────────> : Write bit, for 'Group'
||||└─────────────────────────────────────────> : Read bit, for 'Group'
|||└──────────────────────────────────────────> : Execute bit, for 'User'
||└───────────────────────────────────────────> : Write bit, for 'User'
|└────────────────────────────────────────────> : Read bit, for 'User'
└─────────────────────────────────────────────> : {-, d, l, b, c, s, p}

File type letter                                 Description
------------------------------------------------|---------------
-                                               : Regular file, RAR, txt, jpg, png and so on.
                                                - Can be created in multiple ways, easiest with 'touch' command
d                                               : Directory
                                                - Command: mkdir
b                                               : Block special
                                                - Command: fdisk
c                                               : Character file
                                                - Command: mknod
l                                               : Link file, (soft link or hard link)
                                                - Command: ln
p                                               : Named pipe
                                                - Command mkfifo
s                                               : Socket
                                                - No commands, must be created as part of a program (C-language socket())

When using the 'chmod' command, you  enter 3 numbers
The first number represents the owner
The second number represents the group
The 3rd number represents everybody else.

[Example]
$ chmod 744 filename.sh                         : Permission will look like this -rwxr--w--
$ chmod u+x filename.c                          : Adding execute permission of the file to user
$ chmod g+w filename.c                          : Adding write permission of the file to Group
$ chmod o+r filename.c                          : Adding read permission of the file to 'Other users'

[Example output of 'ls -la']
drwxrwxrwx 1 declined declined  4096 Jan 28 22:29  Guides
                                                : Only included a single sentence
                                                - User, Group and Other all have 'Read', 'Write' and 'Execute'
                                                  permission as specified via -rwxrwxrwx, it is owned by user 'declined'
                                                  owned by group 'declined', it is a directory and the rest is irrelevant for now
                                                
[Example output of "ls -lG"]
drwxrwxrwx 1 declined  4096 Jul 17 14:02  Guides

There are actually 3 additional bits: {setuid,
setgid, sticky}

Much like rwx, they can be viewed with 'ls -l'
command and altered with chmod.
Starting with the sticky bit.
What it does, is specify that only the user and
root are allowed to delete or rename the file
or if the sticky bit is set on a directory, the
files located within that directory.

setuid and setgid are very similar, but with a
slight difference. setuid, refers to users.
setgid refers to group.

When setgid is set on a directory, it cause     : Great for sharing a directory of files among several users, as long as they
newly created files within the directory to take  belong to a common group
on the group ownership of the directory rather  - Behave differently when setgid bit is set on an executable file
than the default group of the user that created
the file.

[Example]                                        Description
------------------------------------------------|---------------
$ chmod +t [directory]                          : Add the sticky bit to [directory]
$ chmod -t [directory]                          : Remove the sticky bit from {directory]
        It is also possible to add or remove the sticky
        bit, using octal characters.
        $ chmod 1777 [directory]                : Add sticky bit to the directory
        $ chmod 777 [directory]                 : Remove sticky bit from the directory


------?--?                                      : -rwxrwxrwx
|||||||||!------------------------------------> : 'x' executable for Everyone
|||||||||!                                      - 't' for sticky bit and executable,
|||||||||!                                      - 'T' for sticky bit
|||||||||!                                      - 's for setuid while also as an executable
|||||||||!                                      - 'S for setuid
||||||!                                         : 's for setgid and also as an executable
||||||!                                         - 'S for setgid

[Example]                                        Description
------------------------------------------------|---------------
$ chmod g+s [file]                              : Add group bit for file
$ chmod g-s [file]                              : Remove group bit for file
$ chmod o+s [file]                              : Add user bit for file
$ chmod o-s [file]                              : Remove group bit for file


There is a bonus concept called file attributes.
It is a list of supplemental flag, that can be
set on files to request special handling.

Flag            : File System                    Description
----------------|-------------------------------|---------------
A               : XBE                           : Never update access time (st_atime; for performance)
a               : XBE                           : Allow writing only in append mode
C               :  B                            : Disable copy-on-write updates
c               :  B                            : Compress contents
D               :  BE                           : Force directory updates to be written synchronously
d               : XBE                           : Do not back up; backup utilities should ignore this file
i               : XBE                           : Make file immutable and undeletable
j               :   E                           : Keep a journal for data changes as well as metadata
s               : XBE                           : Force changes to be written synchronously (no buffering)
X               :  B                            : Avoid data compression if it is the default

Where in the file system column:
                  X = XFS
                  B = Btrfs
                  E = ext3 and ext4

These additional flags can be viewed and altered
with the commands 'lsattr' and 'chattr'.

This is important in case a file contains the
'i' flag.

╔==============================================╗
║               System/User Info               ║
╚==============================================╝
Information related to the OS, and user.
Such as processes, users, calender and more.
Unlike Windows, Linux does not have a Task
Manager, so you need to be comfortable with
commands such as 'top' and 'htop'.

Commands                                         Description
------------------------------------------------|---------------
uname                                           : Print system information
printenv                                        : Print all or part of environment (aka how is your shell setup)
who                                             : Show who is logged on
w                                               : Show who is logged on and what they are doing.
                                                - Also include statistical data and lists what they're doing
whoami                                          : Print effective userid
id                                              : ID number, and associated details with the user such as group
users                                           : Print the user names of users currently logged in to the current host
hostname                                        : Show or set the system's host name (usually shown in your prompt)
                                                  WARNING This is a complicated topic, DO NOT alter your hostname!!!
date                                            : Display the date
cal                                             : Calender
        [month optional] [year]                 - month, and/or year.
iostat                                          : Report Central Processing Unit (CPU) statistics and input/output statistics for
                                                  devices and partitions.
fuser                                           : Identify processes using files or sockets
        -c                                      - Check for current directory
lsof                                            : List open files
file                                            : Determine file type
df [option] [file]                              : Report file system disk space usage
        -h                                      - Human readable
        -H                                      - Print sizes in powers of 1000 (e.g., 1.1G)
du                                              : Estimate file space,
                                                  Summarize disk usage of the set of FILEs, recursively for directories.
                                                  Unlike df, du does not include files that are referenced
        -h                                      - Human readable
top                                             : Provides a dynamic overview of the running processes
htop                                            : Interactive process viewer
ps                                              : Processor Status, it is a highly integrated part of Linux.
                                                  There are more than 80 options, most commonly used is 'aux'
        aux                                     : Display processes of all users.
        -o                                      : User defined format
        -e                                      : Select all processes, identical to -A
        up "[process id(s)]"
vmstat                                          : Reports information about processes, memory, paging, block IO, traps, disks
                                                  and CPU activity
sar                                             : Collect, report, or save system activity information
free                                            : Displays the total amount of free space available along with the
                                                  amount of memory used and swap memory in the system, and also the
                                                  buffers used by the kernel
watch                                           : Reruns a command every 2 seconds.
        free -h                                 - Shows how much memory is in the system
uptime                                          : Tell how long the system has been running
jobs                                            : Display a list of jobs running in the background.
                                                  There is an entire paragraph dedicated to this concept, called 'Job control'.
echo <text>                                     : Prints echoes the <print> in the console
                                                  Has lots of uses, example printing the content of
                                                  a system variable, inserting content into a file, and more.
        -e                                      : Interprets escape characters
printf                                          : An advanced version of echo

[Examples]                                       Description
------------------------------------------------|---------------
$ cal 2021                                      : Will display the calender for the year 2021
$ echo $PATH                                    : Prints the entire path variable
$ echo $PS1                                     : Prints the entire PS1 settings variable, for
                                                  how to display your prompt
$ echo "herp derp" >> filename1.txt             : Insert "herp derp" into a file named 'filename1.txt'
                                                - This command either appends, or creates the file if it does not exist
$ echo -e "derp\a"                              : Prints 'derp' and should also beep
$ printf "%s %d\n" "This many" 4                :
$ ps aux                                        : See all running processes
$ ps -eo pid,user,uid,gid,vsz,rss,comm --sort=-vsz
                                                : Showing the selected categories, sorted descending by vsz
$ ps -eo pid,user,vsz,rss,comm --sort=rss       : Showing the selected categories, sorted ascending by rss
$ ps up "342 8525"                              : Show specific details regarding the two processes with the ID342 and 8525

╔==============================================╗
║               * Process details              ║
╚==============================================╝
Each process have some information related to it.
This paragraph refers to specific usage of the
'ps' and 'top' command.

This part refers primarily to the output of the
'ps' command, no version of the 'ps' command,
contain all of these, or even with the same
format or name.

Command [ps] column names                        Description
------------------------------------------------|------------------------
ADDR                                            : Memory address of the process
C or CP                                         : CPU usage and scheduling information
USER or UID                                     : The user who the process is tied to.
%CPU                                            : How much of the CPU the process is using 
%MEM                                            : How much memory the process is using
PID                                             : Processor ID, each process has a unique ID
PPID                                            : ID number of the process's parent process
PRI                                             : Priority of the process
VSZ or SZ                                       : 'Virtual Memory Size'
RSS                                             : Resident Set Size, it stands for the size of the
                                                  physical memory that the process is using
STAT                                            : The process state mode, such as;
                                                  'Z' zombie,  'S' interruptible sleep,   't' stopped by debugger during tracing,
                                                  'R' running, 'D' uninterruptible sleep, 'T' stopped by job control signal,
                                                  'w' paging,  'l' is multi-threaded,     '<' high-priority (not nice)
                                                  'x' dead,    's' is a session leader,   '+' is in the foreground process group,
START or STIME                                  : At what time the process was started
TTY or TT                                       : "TeleTYpewriter", aka. the console that executed the command
COMMAND                                         : Name of the process, including arguments, if any
                                                  (COMMAND name is often abbreviated)
WCHAN                                           : Memory address of the event the process is waiting for

Moving on to the command 'top', output varies
greatly between the versions and distributions.
General information is found in the 1st row.
You can see how long the system has been up,
how many users are currently logged in to the
system, and how much demand there has been on
the system for the past 1, 5, 10 minutes.

The 'NI' column, stands for 'nice', which is a
parameter used to determine how nice a process
is towards others, it ranges from -20 to 19.
The value directly relates to how nice the
process is to others, by default the value
is '0'.

Shortcuts for 'top' is somewhat different, as
you need to press the shortcuts while the
command is running, rather than supplying it
with arguments.

These shortcuts can be used to display
information in different ways while 'top'
is actively running.

Shortcuts for command [top]                      Description
------------------------------------------------|------------------------
H                                               : See help options, and then press any key to return
                                                  to the top display
M                                               : To sort by memory usage instead of CPU
P                                               : To sort by CPU *(this is the standard setting)
1                                               : The number 1, toggle showing CPU usage of all your CPUs 
                                                  if you have more than one CPU on your system
R                                               : To reverse sort your output.
u                                               : And enter a username, to display processes only for a
                                                  particular user.
r                                               : Renicing a process. Type in the Process ID (PID), of the
                                                  process you wish to alter, and then when prompted, the
                                                  new nice value.
k                                               : Killing a process. Use the process ID, and then type 15
                                                  to terminate the process cleanly, or just 9 to kill the
                                                  process outright.
                                                  Note comparison, command 'kill' vs 'killall'

╔==============================================╗
║              User administration             ║
╚==============================================╝
In general, unless you know exactly what you're
doing, I HIGHLY recommend not touching anything
because of how easily something can go wrong.

Commands                                         Description
------------------------------------------------|---------------
passwd                                          : Used to change the password of users
useradd                                         : Create a new user or update default new user information
        -m                                      - Remembering to also create their home ID
adduser                                         : Add a user to the system
addgroup                                        : Add a group to the system
usermod                                         : Modify a user account
groupadd                                        : Add a new group
groups                                          : Print the groups a user is in
deluser                                         : Deletes user, Debian based distribution, for other types, use
                                                  "userdel" command instead.
        --remove-home [username]                - This syntax is for Debian Distributions
                                                  Will delete the user
chgrp                                           : Change group ownership
        -R                                      - Recursively, to include all files and sub folders located with
                                                  the directory.
chown                                           : Change file owner and group

[Example]
$ useradd -m derp -G sudo -s /bin/sh            : Create user 'derp' part of group sudo, using the /bin/sh shell
$ passwd derp                                   : Change password of 'derp'
$ sudo deluser --remove-home derp               : Removes user 'derp'
$ sudo su - [username]                          : Use root pw to pretend being another user, using their environment variables 
                                                  Remember to exit when done
$ sudo usermod -a -G [groupname] [username]     : Add [username] to group [groupname]
$ groups [username]                             : View the groups that [username] is part of
$ chgrp [group] [file]                          : Alter the group ownership of that directory/file
$ chown [user] [file]                           : Change ownership of file to specified user
$ chown :[group] [file]                         : Change ownership of file to specified group
$ chown [user]:[gropu] [file]                   : Change ownership of file for both user and group

There is a utility called 'Access Control List'
which can be used to set permissions on files
for different users. In order to access the
commands, ACL must be enabled when the
filesystem is mounted.

setfacl                                         : Setting the ACL status of a file
getfacl                                         : Getting the ACL status of a file

[Example]
$ setfacl -m u:username:rwx filename            : -m option, modify permission, for username, to rwx, on file filename
$ getfacl temp.txt                              :

To see whether the ACL status is available on an
ext4 file system use the 'tune2fs -l' command,
to view the implemented mount options.

[Example]
mount -t ext3 -o acl [device-name] [partition]
$ mount -t ext3 -o acl /dev/folderA/folderAA /work

╔==============================================╗
║              Directory commands              ║
╚==============================================╝
Commands related to navigating and altering
directory information.

Commands                                         Description
------------------------------------------------|---------------
pwd                                             : Print working directory
ls                                              : List content of current directory
        -a                                      - Display hidden files
        -l                                      - Provides extra information about each file, the left mode column regarding rwx,
                                                  concerns users priveledge.
                                                - Column format: {permissions, number of links to the file, file owner,
                                                                  group owner, size, date}
        -la                                     - Extra details and hidden files
        /[foldername]                           - List content of specified directory
cd                                              : Change directory
       [empty]                                  - Move to home directory
        ~                                       - Move to home directory
        ..                                      - Move up a directory
        [Directory Name]/                       - Move to specific directory

        <tab><tab>                              - Auto complete
pushd                                           : Save directory into a LIFO stack (directory stack)
                                                  Works much like 'cd' except that the directory you move from
                                                  is stored in the directory stack
popd                                            : Pop the directory from the LIFO stack
dirs                                            : Display directory stack
        -v                                      : Show the list with a bit of formatting
history                                         : Shows a list of commands used so far.
        -c                                      - Reset the the history
mkdir                                           : Make directory (folder)
        [Directory name]                        : new directory
tree                                            : List contents of directories in a tree-like format.
rmdir                                           : Remove directory
        *                                       : wildcard
        [a_zA_Z]*                               - Remove directories starting with specified [a-zA_Z]
        [directory name]                        - Remove specific directory
mkdir [options] directories                     : Creates 1 or more directories

[Example]
$ cd ../../testfolder/                          - Move up two directories, and then down into the testfolder.
$ cd test<tab><tab>                             - Will auto complete the name of a folder starting with 'test' (if it exist)
$ ls -d */                                      - Shows directory names from within that folder.
$ ls */                                         - Show the name and content of the directories, located within the folder.
$ mkdir ab{cd,ef}                               - Creates 2 directories, named 'abcd' and 'abef'

╔==============================================╗
║                 Help section                 ║
╚==============================================╝
If you've got no idea what you're looking at,
it's always nice to know how you can acquire
information about the subject. Or how to search
for something.

Commands                                         Description
------------------------------------------------|---------------
which                                           : Will show where a command is, or whether it is installed
        [command name]                          - Shows location of that command
whatis                                          : Brief description of a command
        [command]                               - tl;dr of that command
apropos [operator] [command]                    : Display information about commands and things that are related to the search
                                                - Display commands related to that command
info [command]                                  : Shows information about a chosen command
man [operator] [command]                        : Manual page for Bash commands
        [command]                               - Shows the manual page for that specific command
        -k                                      - Works as 'apropos', so you can search through man pages,
                                                  linked to the search word.
                                                  Each manual page, has a number, that refers to a category
                                                  To find out what the category means, look at the manual page for man
tldr [command]                                  : Display a tl;dr about command line argument examples
locate                                          : Able to locate specific command locations, and references
                                                  Requires a database to work. (updatedb*)
which                                           : Locate a command
find                                            : Search for files in a directory hierarchy, it has an unusual syntax
        -name [pattern]                         : Search for pattern
        -iname [pattern]                        : Same as '-name' except case sensitive
        -perm                                   : Check for specific permissions
        -lname pattern                          : The name (-name), pathname (-path), or symbolic link
        -regex regexp                           : The path (relative to the directory tree being searched)
                                                  must match the given regular expression.
        -type [f,d,l,b,c,p,s]                   : Only only specific types of files
type [command]                                  : Display where a command is located.
        -a                                      - Display all instances of where the command is located
locate [detail]                                 : Locates a detail on the computer
compgen [Operator] [word]                       : Display possible completions depending on the operator
        -c                                      - List commands, if 'word' is supplied, list those starting with 'word'

[Example]
$ man man                                       - Manual page for the manual command
$ man pipe                                      - Manual page for the pipe command
$ man -k pipe                                   - Shows a list of commands and manual pages related to 'pipe'
$ man 5 <tab><tab>                              - Double tab, to display a list of al manual pages in category 5.
                                                  See table 1.3 found at the bottom, for a description of this concept.
$ compgen -c gr                                 - List commands starting with 'gr'
$ compgen -c | sort                             - List all commands sorted alphabetically
$ tldr man                                      - Displa a few common command options for man
$ info                                          - Info reader documentation (type 'q' to quit)

Commands include a help method, referenced
[command] --help

[Examples]
$ ls --help                                     : List a help category for 'ls' command.
$ chmod --help                                  : List a help category for 'chmod' command
$ find . -name  "*.txt"                         : Find all files who end with a '.txt' format , starting from the current
                                                  directory and recursively look through all sub directories.

╔==============================================╗
║           File access, edit, format          ║
╚==============================================╝
Commands related to files, such as viewing,
altering, acquiring information, sorting,
compressing, and so on.

Text editors                                     Description
------------------------------------------------|---------------
VIM                                             : VIM text editor suite
                                                  There is a paragraph with a tutorial for VIM.
        [filename]                              - Access a specific file via the VIM suite
nano                                            : text editor
        [filename]                              - opens specific file
        [empty]                                 - Open a new document in nano (unsaved version)
emacs                                           : Incredibly powerful, with literally thousands of commands
                                                - Within emacs, use the command '^h' [Ctrl  + h] for help

Additional text exditors:
vi, gedit, jed, joe, kate, kedit, mcedit, nedit
emacs, micro


File alteration                                  Description
------------------------------------------------|---------------
umask                                           : Set file mode creation mask
cp      [source] [destination]                  : copy files and directories
        -i                                      - Add a prompt before overwriting files.
mv      [Source] [Destination]                  : Move (rename) files
        -i                                      - Add a prompt before overwriting files.
rm                                              : Remove (PERMANENTLY)
        ?                                       - Wildcard, for a single character
        *                                       - Wildcard, will remove everything from current directory
        [a_zA_Z]*                               - Will remove everything, starting with the specified name, from current
                directory.
        -r [directory]                          - will remove way too much, DO NOT USE
touch                                           : Update the date of a file, without making changes to the file
        [file name]                             : Can create a new file, if that file does not exist
dd                                              : Copy a file, converting and formatting 

File information                                 Description
------------------------------------------------|---------------
file [option] [file]                            : Determine file type
stat [option] [file]                            : Display file or file system status
     -f [FILE]                                  : File system status
wc [behavior] [filename]                        : Word count - count the number of words in a file
        -l                                      - Count lines, not words

Displaying content                               Description
------------------------------------------------|---------------
cat [option] [filename]                         : 'Concatenate' Show content of file via the terminal
        [Filename]                              - Display content of [Filename]
        >> [Filename]                           - Write something into the file (append), use 'Ctrl + D' to complete.
        > [Filename]                            - overwrite the content of a file, (also create the file if needed)
        << EOF                                  - EOF End of file
more                                            : Look at a file, one page at a time using the spacebar
        [filename]                              - Open the specific file in the command prompt
        q                                       : quits, and goes back to the prompt
less                                            : Same as 'more' just goes one line at a time, you can use spacebar to jump
                                                  forward
        [filename]                              - Open the specific file in the command prompt
        q                                       - quits, and goes back to the prompt
head                                            : View the first lines of a text file
tail                                            : View the last lines of a text file
        -f                                      - Follow, output appended data as the file grows;
strings                                         : Display text that's embedded in a binary file
od [option] [filename]                          : Display a file in Octal or other formats (use option '-x' for Hex)


Sorting, Comparing and Searching                 Description
------------------------------------------------|---------------
diff                                            : Compare files line by line
comm                                            : Compare two sorted files line by line
cmp                                             : Compare two files byte by byte
md5sum                                          : Compute and check MD5 message digest
        --check                                 - Check the Message digest found within a file
shasum                                          : Same as md5sum except with more recent SHA-algorithms
        -a 256                                  : Use SHA-256 algorithm
rev [filename]                                  : Reverse lines characterwise
grep                                            : Print lines that match patterns
cut                                             : Remove sections from each line of lines
        -d[character]                           : Use [character] as a delimiter
awk                                             : Pattern scanning and processing language
sed                                             : Stream editor for filtering and transforming text
uniq                                            : Displaying unique sentences, has additional options over 'sort -u'
                                                  Unique refers to 2 adjacent sentences, therefore often used
                                                  in conjunction with the 'sort' command.
        -c                                      - Count occurences of a sentence
        -d                                      - Only print duplicate lines, one for each group
        -u                                      - only print unique lines without duplicates
sort                                            : Sort via parameters, alphabetically as standard -r for reversed
        -r                                      - Sort in reversed order
        -n                                      - Sort according to string numeral value
        -u                                      - Only show unique occurences of a sentence
        -c                                      - Check if sorted, if it is print nothing else an print an error
        -b                                      - Ignore leading whitespaces in lines


Compression and Decompression                    Description
------------------------------------------------|---------------
tar                                             : An archiving utility
compress
zcat
bunzip2                                         : A block-sorting file compressor
bzip2                                           : a block-sorting file compressor
bzcat                                           : Decompresses files to stdout
zip                                             : Package and compress (archive) files
munpack                                         : Unpack messages in MIME or split-uuencode format
mpack                                           : Pack a file in MIME format

[Examples Compression & Decompression]           Description
------------------------------------------------|---------------
tar cf compressed.tar [files]                   : Compress using .tar extension
tar xf compressed.tar                           : Extract using .tar extension
tar cfz compressed.tar.gz files                 : Compress into compressed.tar.gz format
tar xfz compressed.tar.gz                       : Extract from compressed.tar.gz format
gzip file.txt > compressed.txt.gz               : Compress into compressed.txt.gz format
gzip -d compressed.txt.gz                       : Extract from compressed.txt.gz format
tar cfj compressed.tar.bz2 files                : Compress into compressed.tar.bz2 format
tar xfj compressed.tar.bz2                      : Extract from  format
zip compressed.zip files                        : Compress into compressed.zip format
unzip compressed.zip                            : Extract from compressed.zip format

Depending on your desktop environment, specific
commands may vary, for how to open folders
Types: Gnome, KDE, Xfce, LXDE.

xdg-open [foldername]                           : Opens a folder, should work on a full Linux distribution

[Examples]
$ stat --printf='%n\n%a\n%b\n' [FILE]           : Prints 3 options, %n, %a, %b, with line breaks.
$ cat file1.txt | more                          : Display file1.txt in the console, using 'more' format
$ cat file1.txt | less                          : Display file1.txt in the console, using 'less' format
$ cat file1.txt | head                          : Display the first 10 lines of file1.txt in the console
$ cat file1.txt | tail                          : Display the last 10 lines of file1.txt in the console
$ ls -a | sort -r | less                        : List content of directory, in reversed alphabetical
order, using 'less' format.
$ diff <(wc file1) <(wc file2)                  : Compares the wordcount of 2 different files
$ cp a.txt b.txt ; rev b.txt > a.txt ; rm b.txt : Reversing the content of a file, line by line.
$ sort sometxt.txt | uniq -c | sort -nr         : Sort a file, and display in order how many times a sentence occured
$ cat /etc/passwd |cut -d: -f1                  : Count the number of users on a system
                                                - cat ... show the content in the terminal
                                                - cut use a delimiter ':', and focus on the first column
$ ls -l | awk '{ print $2 }'                    : Print only the 2nd column
$ sed 's/linux/derp/g' somefile.txt             : Replaces all occurences of the word 'linux' in a file with the word 'derp'
$ man -k xdg                                    - Use this command to check status of xdg commands in general
$ md5sum derp > something.txt                   : Store the Message Digest, along with the filename within 'something.txt'
$ md5sum --check something.txt                  - Compares the cheksum found within, against the checksum of the filename
                                                  specified in the file
$ md5sum [file] | md5sum --check                : Create and check on the same line

╔==============================================╗
║          Packages and installations          ║
╚==============================================╝
Update/upgrade dependencies and installed
content (use sudo), theres' a massive difference
between debian and .rpm based distros.
Debian based distributions handle dependencies
directly when you acquire and install packages.
Wish I could say the same for .rpm distros.

Debian based distros use "apt" or "apt-get" as
a package manager, for a detailed list, use
these two commands.

$ apt-get --help
$ apt --help

There is also a debian tool called 'dpkg', it
is on a lower abstraction level than 'apt' as
it can install .deb packages directly,
if they've been downloaded manually,
unfortunately dependencies are not resolved.

In order to run most of the options related to
installing or removing packages you need to
use sudo privileges.

These are the most commonly used debian based
commands:                                        Description
------------------------------------------------|---------------
$ sudo apt-get update                           : Retrieve new lists of packages
$ sudo apt-get upgrade                          : Perform an upgrade of packages
$ sudo apt-get build-essential                  : A collection of packages required to compile and run a number of different
                                                  programming languages, such as C, C++
$ sudo apt search [NAME]                        : Display a list of available packages related to the search parameter
$ sudo apt-get install [PACKAGE]                : Install package
$ sudo apt install [PACKAGE]                    : Install package
$ sudo apt-get dist-upgrade                     : Update the kernel packages
$ sudo apt-get purge [PACKAGE]                  : Packages are removed and purged (any configuration files are deleted too).
$ sudo apt autoremove                           : Uninstall dependencies that are no longer needed

[Example DEB based]                              Description
------------------------------------------------|---------------
$ apt-cache search media                        : Find packages related to media
$ sudo apt search music                         : Find packages related to music
$ sudo apt-get install [PACKAGENAME]            : Install a specific package, i.e. nmap
$ sudo apt install nmap                         : Install nmap

And similar for .rpm distros, these two are the
primary method for managing and installation.    Description
------------------------------------------------|---------------
yum [option] [command]                          : (For RPM distros) Install, Uninstall, Update Packages
                                                  Now outdated 
dnf [option] [command]                          : (For RPM distros) 'Dandified YUM', it is an upgraded version of YUM,
                                                  available since version 18 of Fedora. Syntax somewhat identical to YUM

.rmp usecases                                    Description
------------------------------------------------|---------------
$ yum provides dvdrecord                        : A method to search for packages, if you know either the 'configuration file',
                                                  'library name' or 'command', but don't known which package it is located in.
$ yum search [partial name]                     : Looks for the partial name in the description of packages.
$ yum info emacs                                : Shows info about a package
$ yum history                                   : Has an undo option, where you can undo package installations.
$ yum list emacs                                : List package names in different ways, to find the version and repository of
                                                  a package.
$ yum install emacs                             : Install the emacs package (May require additional dependency installations)
$ yum reinstall emacs                           : Reinstalling a package if you messed something up
$ yum check-update                              : Check for updates for all packages on the system
$ yum update                                    : Update a single package or to get updates to all packages that are installed
                                                  and have an update available.
$ yum grouplist                                 : Show a list of package groups
$ yum groupinstall [name]                       : Installing a package group


It is possible to directly download and install
packages, but be vary of this method, as it may
cause some problems with the package managers
on your system.
In either case, once you've downloaded the file
which is usually a .tar.gz or tar.bz2 format.
You unzip it, and then run these 3 commands.

$ ./configure    
$ make
$ sudo make install

╔==============================================╗
║                  Networking                  ║
╚==============================================╝
Commands related to networks.

Commands                                         Description
------------------------------------------------|---------------
ssh                                             : OpenSSH remote login client, remote access to a host
netstat                                         : Printing network connections, routing tables, interface statistics,
                                                  masquerade connections, and multicast memberships
ss                                              : Another utility to investigate sockets
ip                                              : ip - show/manipulate routing, network devices, interfaces and tunnels
ifconfig                                        : Configure a network interface
nmap                                            : Network exploration tool and security/port scanner
route                                           : Show/manipulate the IP routing table
arp                                             : Manipulate the system ARP cache
        -e                                      - Use default Linux style output format (with fixed columns).
arp-scan                                        : The ARP scanner
wget                                            : Retrieve web pages/files to disks
        -O [newname] [link]                     - Output option, in case you want to rename the file
        -b                                      - Run in background, to see the status use the command "tail -f wget-log"
        -C                                      - Resume download, in case networking dropped, rather than starting from scratch.
curl                                            : Transfer a URL (pretty much the same as wget)
ftp                                             : Copy files to/from a remote host
sftp                                            : Same as 'ftp' only this is a secure version
scp [from] [to]                                 : Secure copy (remote file copy program)
                                                - Uses ssh in the background
        -P                                      - Port Number
whois                                           : Client for the whois directory service
iptables                                        : administration tool for IPv4/IPv6 packet filtering and NAT
host                                            : DNS lookup utility
ping -[operator] [website]                      : Pings a website with packages
traceroute                                      : Print the route packets trace to network host
dig                                             : DNS lookup utility
nslookup                                        : Query Internet name servers interactively
                                                  There is a paragraph dedicated to the usage of this command
tcpdump                                         : Dump traffic on a network
socat                                           : Multipurpose relay (SOcat CAT)
                                                - The socat utility is a relay for bidirectional data transfers between two
                                                  independent data channels. 
ufw                                             : Program for managing a netfilter firewall

[Example ssh server]                             Description
------------------------------------------------|---------------
$ service ssh status                            : View status of the ssh server
$ service ssh restart                           : Restart the server
$ sudo systemctl status ssh                     : View status of the ssh server
$ service ssh start                             : Start the ssh
$ service ssh stop                              : Stop the ssh
$ sudo systemctl stop ssh                       : Start the ssh
$ sudo systemctl start ssh                      : Stop the ssh
$ sudo systemctl enable ssh                     : Enable automatic start when computer boots
$ sudo systemctl disable ssh                    : Disable automatic start when computer boots
$ ip a                                          : Use this command to find the ip of your server

For settings on the server, edit the ssh config
file located at /etc/ssh/sshd_config:
| PubkeyAuthentification yes                    :
| PasswordAuthentification yes                  :
| PermitRootLogin no                            :

[Firewall example]
------------------------------------------------|---------------
$ sudo ufw status                               : Show status of firewall and ufw managed rules
$ sudo ufw allow ssh                            : added ssh access to the firewall
$ sudo ufw delete allow ssh                     : Removed ssh access from the firewall

[General examples]
------------------------------------------------|---------------
$ ping -c 100 google.com                        : Pings google.com with 100 packets, and provide you with statistics afterwards.
$ host google.com                               : Show DNS information about google.com
$ ip addr show                                  : View all loaded network interfaces
$ ip monitor
$ ip route                                      : Show the routing table (includes default gateway)
$ traceroute yahoo.com                          : Display a traceroute to yahoo.com with 2 sec 
$ netstat -antu                                 : Display the active network connections: all connections, don't resolve host names,
                                                  meaning that port 80 isn't translated to http, display TCP and UDP connections

For RHEL systems, check file:
/etc/sysconfig/network-scripts/ifcfg-eth0
For Debian systems, check file:
/etc/network/interfaces 

[Example socat]
$ socat TCP-LISTEN:400,reuseaddr,pf=ip4,fork -
[new terminal]
$ socat TCP:localhost:4000 - 
herpti derpti derp
[Previous terminal]
: Here the "herpti derpti derp" should appear   :

[Example scp]
This example assumes you have a server already
setup to connect via ssh.
$ scp -P [port number] user@yourserverip:derp.txt /some/local/directory
                                                : Move a file called 'derp' located at
                                                  the home directory of your account on the server, to 
                                                  your own computer on some local directory specified by the absolute path.
$ scp -P [port number] derp.txt user@yourserverip:/some/remote/directory
                                                : Move a file called 'derp.txt' located at
                                                  the current directory on your local machine to
                                                  to the server at '/some/remote/directory' specified by the absolute path.

The host file is located at 
/etc/hosts
On the website someoneonewhocares.org is an
interesting host file you can use.

╔==============================================╗
║                   VARIABLES                  ║
╚==============================================╝
For a complete list of variables, use command
$ echo $<tab><tab>                              : Two tabs, for an auto complete

Some usefull variable names                      Description
------------------------------------------------|---------------
$HOME                                           : Home directory
                                                  It is your current working directory each time you log in
                                                  or type the cd command with any option.
$PATH                                           : OS variable path.
                                                  It is a colon-separated list of directories used to.
                                                  find commands that you type.
$OSTYPE                                         : This name identifies the current Operating System type.
$PWD                                            : Print working directory.
$BASH_VERSION                                   : Represents the current bash version.
$USER                                           : Abbreviation of the username, this is a system variable.
$PS1                                            : Where the bash shell formatting is stored, i.e. format and colors.
                                                  There is a paragraph dedidacted to this called "Setting your prompt".

These are used in programming (and herefore
NOT the commmand line)
stdin                                           : Standard input (console), where the program reads from. (0)
                                                - File descriptor 0
stdout                                          : Standard output (console/screen) where the info will be displayed.
                                                - File descriptor 1
stderr                                          : Standard error, using file descriptor #2, usually writes to console.
                                                - File descriptor 2

╔==============================================╗
║           FUNCTIONS-(NOT COMMANDS)           ║
╚==============================================╝

Navigate command history                         Description
------------------------------------------------|---------------
[arrow up]                                      : Display previous command.
[arrow down]                                    : Display next command.
[ctrl + R]                                      : Reverse search of command history
[ctrl + Q]                                      : Exit reverse search of command history, without activating command.


Expressions                                      Description
------------------------------------------------|---------------
$[expression]                                   : Arithmetic expression, direct.
$((expression))                                 : Arithmetic expression, direct.
$(expression)                                   : Arithmetic expression, via function.

[Example]
$ echo "Derp $[56 - 43]"                        : Echoes "Derp 13" in the console.
$ echo $[56 - 43]                               : Echoes "13" in the console.
$ echo "Derp $((3+4*2))"                        : Echoes "Derp 11" in the console.
$ echo $((3+4*2))                               : Echoes "11" in the console.
$ echo "Derp $(ls | wc -w)"                     : The content of ls is piped to word count command that prints
                                                  the number of words in the folder.

|                                               : Pipeline character, Special circumstance(!!!).
                                                  This character is used to send the output of one command, to another command
                                                 
                                                  
<('content')                                    : A method to condense the input, and use it as an argument.
./[filename]                                    : Running an executable file (compiled file, or shell file).

[Example]
$ history | less                                : Will show the history using the 'less' format
$ history | grep derp                           : Will search the history and 
$ diff <(wc file1) <(wc file2)                  : Compare at the difference between the word count of 2 files

Wildcard types:                                  Description
------------------------------------------------|---------------
*                                               : Used as a wildcard for an string of undetermined length
?                                               : Used a wildcard for a single character in strings.
.                                               : Used a wildcard for a single character in strings.
[...]                                           : Matches any one of the characters between the brackets, which can
                                                  include a hyphen separated range of letters or numbers.
                                                  Used for pattern matching, case sensitive.
{...}                                           : Pattern generation, strings are separated by comma, numbers by 2 dots (..)
[set]                                           : Any single character in the given set, most commonly a sequence of characters,
                                                  like [aeiouAEIOU] for all vowels, or a range with a dash, like [A-Z] for all
                                                  capital letters.
[^set]                                          : Any single character NOT in the given set, such as [^0-9] to exclude any
                                                  digits.
[!set]                                          : Same as [^set]

[Examples]
$ touch derp{1..4}                              : Creates 4 files, derp1, derp2, derp3, derp4
$ touch derp{ty,ti}                             : Creates 2 files names derpty and derpti
$ rm derp*                                      : Remove all files starting with the name "derp"
$ ls [0A]*                                      : List all files starting with 0 or A
$ ls ?[2A]*                                     : List all files where the 2nd character is either '2' or 'A'
$ sudo dmidecode | grep -A20 '^System Information'
						: Display 20 lines, starting from the line 'System Information'

Boolean operators                                Description
------------------------------------------------|---------------
;                                               : Combining commands to be run in a sequence
&&                                              : Run a sequence of commands, but stop execution if any of them fails,
||                                              : Run a sequence of commands, but stop when the first command is true

[Examples]
$ command1 && command2 && command3              : Execute command1, then command2, then command3
$ cd .. ; cd folder1/                           : Move up 1 directory, then move back down into another directory
$ apt-get update || echo "Derped out"           : Without root access, this will derp out.

!!                                              : Rerun previous command
!*                                              : Last parameter from previous command
!?[string]?                                     : Reruns a previous command, containing the [string]

[Examples]
$ !?cal?                                        : Reruns a previous command containing 'cal' if found
$ sudo !!                                       : Redo last command as root user
$ ls z* && rm !*                                : Here '!*' is treated as 'z*', so first we list all files starting with z,
                                                  Then delete those files

clear                                           : Clears the bash terminal of text
exit                                            : Terminates current access (Super User, bash, cmd, ...)
logout                                          : Logs out, but recommended to use 'exit' instead.
--                                              : "end of options", meaning that anything shown after that option will be
                                                  disregarded.

>> [filename]                                   : Append into the file (add at the end of the file)
> [filename]                                    : Save content into file
<                                               : Directs the standard output of a command to a file. If the file exists,
                                                  the content of that file is overwritten
2>                                              : Directs standard error(error messages) to the file.
&>                                              : Directs both standard output and standard error to the file
2>&1                                            : Appends stderr to stdout
$?                                              : Returns the error code from the previous command or executed program

[Examples]
$ ./derp >> derpy.txt                           - Will send the content from the compiled program (derp) to be
                                                  appended in the file 'derpy.txt' rather than shown on the console.
$ ./derp > derpy.txt                            - Will send the content from the compiled program (derp) to 
                                                  overwrite content of file 'derpy.txt' rather than shown on the console.
$ ./derp 2> /dev/null                           - Display normal messages (stdout) on the screen, but error messages (stderr) are
                                                  discarded
$ ./derp 1> /dev/null                           - Only display error messages, since normal messages (stdout) are discarded 
$ ./derp 2>&1                                   - stderr messages are appended to the stdout messages

There is also a command called 'expr' which can
do basic math calculations, and regex.

[Examples]
$ expr 324 - 5123                               : Output -4799
$ expr length 32094ij+NJIfe3#¤                  : Output 16

╔==============================================╗
║            Command line shortcuts            ║
╚==============================================╝
How to navigate the command console.
Mostly useful commands pasted first.
Rest unsorted.

Shortcut                                         Description
------------------------------------------------|---------------
[ctrl + C]                                      : Kills a command, if a command is continuously running (example: htop).
[ctrl + D]                                      : Terminate command window. (same as exit)
[ctrl + A]                                      : Beginning of line, go to the beginning of the current line.
[ctrl + E]                                      : End of line, go to the end of the line.
[ctrl + L]                                      : Clears the bash terminal of text.
[alt + .]                                       : Paste the argument from the previous command

[ctrl + K]                                      : Cut end of line, cut text to the end of the line.
[ctrl + U]                                      : Cut beginning of line, cut text to the beginning of the line.
[ctrl + R]                                      : Reverse search of command history
[ctrl + Q]                                      : Exit reverse search of command history, without activating command.

[ctrl + F]                                      : Character forward, go forward one character.
[ctrl + B]                                      : Character backward, aka. go backward one character.
[ctrl + D]                                      : Delete the current character (aka 'delete' key).
[ctrl + T]                                      : Transpose words, switch positions of current and previous characters.
[ctrl + V]                                      : Insert special character, add a special character.
                                                - For example, to add a Tab character, press [Ctrl+V+Tab].
[ctrl + W]                                      : Cut previous word, cut the word located behind the cursor.
[ctrl + Y]                                      : Paste recent text, paste most recently cut text.
[alt + Y]                                       : Paste earlier text, rotate back to previously cut text and paste it.

[alt + F]                                       : Word forward, go forward one word
[alt + B]                                       : Word backward, go backward one word
[alt + T]                                       : Transpose words, switch positions of current and previous character
[alt + U]                                       : Uppercase word, change the current word to upper case
[alt + L]                                       : Lowercase word, change the current word to lower case
[alt + C]                                       : Change the current word to an initial capital
[alt + D]                                       : Cut the word following the cursor
[alt + 1]                                       : Access the 1st argument from the previous command
[alt + 2]                                       : Access the 2nd argument from the previous command
...                                             : And so on

╔==============================================╗
║                   HARDWARE                   ║
╚==============================================╝
Managing the hardware details, such as removable
USB drives, hardware plugged in during boot, 
and more.

Command                                          Description
------------------------------------------------|---------------
dmesg                                           : Print or control the kernel ring buffers
                                                  Used to view or alter which hardware was detected and which
                                                  drivers were loaded by the kernel at boot time.
journalctl                                      : Query the systemd journal
                                                  Can be used to view boot messages, and show messages
                                                  messages associated with a particular boot instance.
fdisk                                           : Manipulate disk partition table
                                                - Display more information than the lsblk command
lsblk                                           : List block devices
        -f                                      - Output  info  about  filesystems
lspci                                           : List all PCI devices
lsusb                                           : List all USB devices
lscpu                                           : List all PCU devices
lsmod                                           : Show the status of modules in the Linux kernel
lshw                                            : List hardware (warning, should be run as a super user)
modinfo                                         : Show information about a Linux Kernel module
rmmod                                           : Simple program to remove a module from the linux Kernel
modprobe                                        : Add and remove modules from the Linux Kernel
mount                                           :
umount                                          : Unmount file systems   
eject                                           : Used to eject USB/DVD and similarly mountable drives

[Example]
$ lscpu | grep cache                            : Display cache levels for the CPU

Hard drives, can be divided into several
partitions, each with their own file system.

In Windows, partitions are handled automatically
(if reckognized) and are placed next to the
'C:' drive, thus clearly sectioned apart within 
the Windows OS.

It is different and quite unique for Linux.
In Linux, partitions added directly into
the existing directory stucture.
This require a mount point, within the existing : THIS IS A REQUIREMENT(!!!)
Linux OS file structure to be created, and ready
to accept the new partition.
This mount point should (highly recommended) be
empty, otherwise the files already located
within, will become hidden. (Not deleted)
Until the partition is demounted.

When handled automatically, partitions are
usually located at /mnt/... for regular drives,
or /media for removable media devices, such as
DVD or CD.

Som basic info about common file systems, and
denominators between Windows OS, and Linux OS.

File System                                      Description
------------------------------------------------|---------------
VFAT                                            : Lowest common denominator between Linux and Windows.
                                                  Often used by USB-drives
exFAT                                           : Often used by USB-drives
                                                  Linux may support it, if not requires additional kernel drivers.
NTFS                                            : Standard file system for Windows
                                                  Linux may support it, if not requires additional kernel drivers.

Ext4 is the standard file system for Linux.

You can view disk partitions with the command:
$ parted -l 
You can display the disk list using the lsblk
command.
$ lsblk
This is the syntax for the 'mount' command.
mount [options] <-t type> [-o mount options] <device> <mounting point>
                                                : Syntax for the mount command

For most scenarios, these are the steps that you
are going to go through:
1. Display the disk list using the lsblk command
2. Create a new directory to be mounted (this is
where you will access the USB stick drive).
3. Mount the USB drive using the mount command

Assuming you've plugged in the drive/usb.
Step 1. use the lsblk command
$ lsblk
Find the disk we're looking for, so that we have
the path, to be used for the next step.

Step 2. Create a directory
$ mkdir /mnt/derpydirectory

Step 3. Mount the drive/use to the mount point
$ sudo mount /dev/sdb1 /mnt/derpydirectory      : Remember to substitute /dev/sdb1 with the correct path for your drive

All done, once you're complete, you can unmount
the drive with the command umount.

$ umount /mnt/derpydirectory

Printing                                         Description
------------------------------------------------|---------------
lpr                                             : Print a file.
        -P [PrinterName] MyFile                 - Print a specific file on a specific printer which has been setup
        -a                                      - List the queue for all printers
lpq                                             : View the print queue.
lprm                                            : Remove a print job from the queue

╔==============================================╗
║                 VIM tutorial                 ║
╚==============================================╝
'Vi' is often the default text editor for Linux,
VIM is the upgraded version, and an editor of
choice for many.
It is a "modal" text editor, meaning that it has
different modes available, such as:
command(default), insert, last-line, and 
possibly more, depending on whom you ask.

In command mode, you have access to very
different tools, such as saving, exiting, 
highlighting, and so on,
Whereas 'insert'-mode is about editing the 
content of the file directly.

If you're in 'insert'-mode, hit the ESC
key, to go to the Command mode.

Obviously arrow keys work the same.

These are some of the most common
shortcuts that you are going to need.

Shortcuts:
Command-mode                                     Description
------------------------------------------------|---------------
i                                               : Switch to 'Insert' mode.
I                                               : Switch to 'Insert' mode, but move the cursr to the beginning of the line
a                                               : Append, same as 'i', except the cursor is moved to the end of the word
A                                               : Append, same as 'i', except the cursor is moved to the end of the line
[CTLR + V]                                      : Highlight 1 column at a time
v                                               : Highlight one character at a time
p                                               : paste text after the current line
                                                : paste text on the current line
x                                               : Delete character
dw                                              : Delete from the cursor up to the next word
d$                                              : Delete from the cursor to the end of a line
dd                                              : Delete a line
y                                               : Yank text into the copy buffer 
u                                               : Undo
U                                               : Undo a whole line
[CTRL + R]                                      : Undo an undo (redoing your last undo)
p                                               : Put previously deleted text after the cursor
r[Character]                                    : Replace the character highlighted by the cursor with [Character]
ce                                              : Change until the end of a world
                                                - Notice that ce deletes the word and places you in the 'Insert' mode
?text                                           : Search for 'text', then use '/' to move forward, and '?' to move backward.

Commands(Command mode)                           Description
------------------------------------------------|---------------
:q                                              : Quit the file (adds a prompt if changes were made to the file)
:q!                                             : Force quit the file
:wq                                             : Save and quit
:ter                                            : Open a terminal window
:h                                              : Help
:ju                                             : List of jumps

Cursor movement(Command mode)                    Description
------------------------------------------------|---------------
h                                               : Moves the cursor one character to the left.
j                                               : Moves the cursor down one line.
k                                               : Moves the cursor up one line.
l                                               : Moves the cursor one character to the right.
H                                               : Move the cursor to the top of the screen
M                                               : Move to the middle of the screen
L                                               : Move to the bottom of the screen
w                                               : Jump forward to the beginning of the next word.
W                                               : Jump forward to the beginning of the next word.
                                                - Words can contain punctuation
e                                               : Jump forward to the end of a word
E                                               : Jump forward to the end of a word
                                                - Words can contain punctuation
b                                               : Move backward to the beginning of the previous word
B                                               : Move backward to the beginning of the previous word
                                                - Words can contain punctuation
ge                                              : Jump backward to the end of the previous word
gE                                              : Jump backward to the end of the previous word
                                                - Words can contain punctuation
^                                               : Jump to the first non-blank character of the line
g_                                              : Jump to the last non-blank character of the line
$                                               : Jump to the end of the line
0                                               : Jump to the beginning of the line.
G                                               : Move to the end of the file.
gg                                              : Move to the beginning of the file
f[character]                                    : Jump to the next occurance of [character]
F[character]                                    : Jump to the previous occurance of [character]
t[character]                                    : Jump to before next occurence of [character]
T[character]                                    : Jump to the previous occurence of [character]
;                                               : Repeat previous f, F, t or T movement
,                                               : Repeat previous f, F, t or T movement backwards
}                                               : Jump to the next paragraph
                                                - Or function/block when editing code
{                                               : Jump to the previous paragraph
                                                - Or function/block when editing code
zz                                              : Center cursor on screen
%                                               : Move  to matching character 
                                                - Default supported pairs: '()', '{}', '[]'
                                                - use :h matchpairs in vim for more info
`.                                              : Move to the last edit.
[Ctrl + e]                                      : Move screen down one line without moving the cursor
[Ctrl + y]                                      : Move screen up one line without moving the cursor
[Ctrl + f]                                      : Move forward one full screen
[Ctrl + d]                                      : Move forward ½ a screen
[Ctrl + b]                                      : Move backward one full screen
[Ctrl + u]                                      : Move backward ½ a screen

Some of these commands can be 'prefaced',
meaning that if you use the command 10b, you
move back 10 words. Or if you use 11w, move
forward 11 words, and so on.

Quick tips.
------------------------------------------------|---------------
1 character movement
             ^                                  : The k key is up
             k                                  : The h key is at the left and moves left.
       < h       l >                            : The l key is at the right and moves right.
             j                                  : The j key looks like a down arrow.
             v

Part of the screen
             ^
             H                                  : The H key moves the cursor to the top of the screen
             M                                  : The M key moves the cursor to the middle of the screen
             L                                  : The L key moves the cursor to the bottom of the screen
             v

Move a full screen
             ^
         [Ctrl + b]                             : Move backward one full screen
         [Ctrl + f]                             : Move forward one full screen
             v


If you want an interactive tutorial use the
command: "vimtutor"
$vimtutor

╔==============================================╗
║                 Uncategorized                ║
╚==============================================╝
:p                                              : prints a command rather than executing it
:s                                              : Substitute argument with something else
:t                                              : Strip path from an argument
:r                                              : Strip file extension from an argument
:g                                              : Affect all occurences of a word

[Example]
$ mkfifo [pipeline]                             : Create a  (aka a Named pipe) called [pipeline], some arbitrary name
$ ls -la > [pipeline]                           - Send something through the pipeline
$ cat < [pipeline]                              - Display the content of the pipeline

awk                                             : Awk is a scripting language used for manipulating data and
                                                  generating reports. By itself it goes beyond the scope of
                                                  this file, and would thus require a guide by itself, even
                                                  if the topic is relatively lightweight.
make                                            : GNU make utility to maintain groups of programs
                                                  Requires additional knowledge to setup for projects via makefile
rm .test.c.sw*                                  : Deletes both .sw files for 'test.c' (In case of errors)
                                                  //compiler course
chage                                           : Change user password expiry information
size                                            : Display the size of a compiled C program, and how data is stored.
time                                            : Display the time used to execute a command and print the time for
                                                  {real-time, CPU-time and system CPU time}
screen                                          : Screen manager with VT100/ANSI terminal emulation
                                                  It is a full-screen window manager that multiplexes a physical
                                                  terminal between several processes.
                                                  Beware that running text editors may be problematic, as 'screen'
                                                  have full control over the keyboard unless control is relinquished.
xargs [options] [command]                       : Build and execute command lines from standard input
                                                  This tool is incredibly powerfull, as you can supply it with
                                                  different paths which can be used as arguments, and then processed.

[Example]
find . -type f -print | xargs grep -l derp      : Find any files with the word "derp" located within.


Spell Checking                                   Description
------------------------------------------------|---------------
look                                            : Look up the spelling of a word quickly.
aspell                                          : Interactive spelling checker.
        -c [file]                               : Check spelling on all words within a file
        dump master                             : Show the content of the master dictionary
        help                                    : See the help page
spell                                           : Batch spelling checker.

Python trick for C programming.
If you've compiled a C program that requires a
single input, you can use python to simulate it.
[Example]
./program < <(python -c "print('someinput')")   : The output of the python is treated as an input to the program.
                                                  The -c option, mean that the (python)program, is passed in as a string

objdump                                         :
nm
readelf
$ objdump -d <binary_name>

[Security]
$ ssh-keygen -t rsa -b 4096                     : Creating a 4096 bit RSA public key, to be stored in
                                                  /home/user/.ssh/id_rsa.pub
                                                - The '-t' option refers to the type of key to generate, RSA is the most common.
                                                  Could also have been other types such as: dsa, ecdsa, ecdsa-sk, ed25519, ed25519-sk  
                                                - The '-b' option refers to the bit length. Minimum is 1024 default is 3072 bits.
[DTU specific]
Details for accessing the LSF 10 cluster on DTU
via a linux terminal
http://www.cc.dtu.dk/?page_id=2501
[Example]
$  ssh userid@login1.gbar.dtu.dk                : Substitute userid with your student ID.
                                                - Type in your password, and you should now have acess to the LSF 10 cluster
                                                - Hit [CTRL + C] if you screw up
If necessary, use this command to access a
new node.
$ linuxsh                                                 
Use cd, pwd, ls -l commands, to navigate to
the desired folder.

You can forward shell scripts to be run on the
server with the bsub command.
[Example]
$ bsub < example.sh

To look at the job queue, use the command
'bjobs'
[DTU end]

╔==============================================╗
║                  References                  ║
╚==============================================╝
Sources:
- 62588 Operating Systems Lectures
- 62501 Linux Server and Network materials
- Linux manual pages
- https://www.youtube.com/watch?v=oxuRxtrO2Ag
- Linux Pocket guide
- Linux Bible by Christopher Negus (Once you get past the fluff, it's ok)
- https://en.wikipedia.org/wiki/Linux_distribution
- https://en.wikipedia.org/wiki/List_of_Linux_distributions
- https://www.howtogeek.com/656549/how-to-delete-a-user-on-linux-and-remove-every-trace/
- https://acloudguru.com/blog/engineering/conditions-in-bash-scripting-if-statements
- https://www.geeksforgeeks.org/awk-command-unixlinux-examples/
                                                : AWK 
- https://man7.org/linux/man-pages/man1/ps.1.html
                                                : Man page for ps
- https://www.computerhope.com/unix/visudo.html : Editing using the visudo command
- https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/
                                                : Makefile explanation, by extension, the next link as well.
- http://www.gnu.org/software/make/manual/make.html
- https://www.linux.com/training-tutorials/vim-101-beginners-guide-vim/
                                                : VIM tutorial
- https://vim.rtorr.com/                        : VIM shortcuts
- http://samrowe.com/wordpress/advancing-in-the-bash-shell/
                                                : Details concerning the use of colon (:) operators for arguments



╔==============================================================================╗
║    Advanced topics                                                           ║
║    This section is well beyond the scope of users new to the                 ║
║    command console.                                                          ║
║          : Topics                                                            ║
║               -  Creating your own shell environment                         ║
║               -  Setting your prompt                                         ║
║               -  Adding environment variables                                ║
║               -  Job control                                                 ║
║               -  Managing groups                                             ║
║               -  Shell scripting                                             ║
║               -  System calls                                                ║
║               -  Commmon knowledge                                           ║
║               -  [Command] nslookup                                          ║
║               -  [Command] tmux                                              ║
║               -  [Command] cron                                              ║
║          : Table list                                                        ║
║               -  Table 1.0: Useful abbreviations                             ║
║               -  Table 1.1: Bash Configuration files                         ║
║               -  Table 1.2: Characters to add information to bash prompt     ║
║               -  Table 1.3: Manual page sections                             ║
║               -  Table 1.4: (Some of) Linux directory information            ║
║               -  Table 1.5: Signals available in Linux                       ║
║               -  Table 1.6: Control group limiting options                   ║
║               -  Table 1.7: Operators for test expressions(Shell scripting)  ║
║               -  Table 1.8: Important files on the Linux OS                  ║
║          : References                                                        ║
╚==============================================================================╝

╔==============================================╗
║      Creating your own shell environment     ║
╚==============================================╝
It is possible to make alterations to the shell
to work more efficently.
Such as: Setting new aliases to store
information, shortcuts to folders, favorite 
commands, and more.
By adding these alterations to the right 
configuration files, you can ensure they're
always available whenever you open a new shell.

* Configuring your shell
There are seveval configuration files that
determine how you shell behaves. Some are tied
to every user and every shell, but others are
tied to the specific user who created the
configuration file.

Table list 1.1 shows the files that are of
interest to anyone using the bash shell in
Linux. (Notice the use of ~ in the filenames to
indicate that the file is located in each user's
home directory.) To change the /etc/profile or
/etc/bashrc files, you must be the root user.
It is better to create an
/etc/profile.d/custom.sh file to add system/wide
settings instead of editing those files directly,
however. Users can change the information in the
$HOME/.bash_profile, $HOME/.bashrc, and
$HOME/.bash_logout files in their own home
directories.

[Example 1]
To edit the environment, we want to alter the
configuration file $HOME/.bashrc, as a plaintext
file via 'vim', we use the command
$ vim $HOME/./bashrc
Go to the bottom and include an extra line
alias derp='watch free -h'
A new alias has now been set, to access the
command without having to restart the console
use this command $ source $HOME/.bashrc
Alternatively, restart the console.
Can be done with the command 
$ exec bash

There is also a specific command called 'set',
this command is used to alter shell attributes
and positional parameters, and can even be used
within shell scripts.

The current set of flags can be found in $-
Use the command '$ echo $-' to view them.
Some default flags are 'himBHs'.
It is often used in conjuction with shell
scripting.

Command                                          Description
------------------------------------------------|---------------
set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]
                                                : Command format for 'set'

One big advantage is that it is possible to
alter how command line editing works with set.
[Example]                                        Description
------------------------------------------------|---------------
$ set -o emacs                                  : Use emacs editing style
$ set -o vi                                     : Use vi editing style

╔==============================================╗
║              Setting your prompt             ║
╚==============================================╝
The prompt, are the characters that appear on 
the command line on the shell, to the left of
when you enter commands.
The details for how that is set up, is found 
within the PS1 environment variable.
The PS2-PS4 variables are used for additional
input.

When installed, the prompt is usually set up
to contain {Your username, your hostname, 
the base name of your current working directory}
For regular users, they're followed by a dollar
sign ($), and pound sign (#) for the root user.

Here is an example of that prompt:
[declined@LAPTOP-E9IBLV7O: folderA] $

By changing directory, the folderA name would
change to the name of the new directory.
If we were to switch to a different user, or
system that information would change as well.

It's possible to alter the prompt significantly
to even include a date, terminal number and 
additional pieces of information.

Table 1.2 show some examples of characters to
add information to Bash prompt.
For additional info, see the bash man page.

Changing to the PS1 variable directly, is only
valid until the prompt is restarted.
To make it permanent, you need to alter the
value within the .bashrc file found in your
home directory.
There may already be a PS1 variable, within
that file which can be modified, although
a safer solution would be to uncomment the 
setence, and write your own custom settings.
So that you can revert easily to a prior 
setting.

There is a link in references with a HOWTO
for changing colors commands and other
features of your bash shell prompt.

[Example]
Alter the PS1 variable, remember to store it
first, and know that it is only valid until
you restart the shell.
$ temp=$PS1
[For debian]
$ PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
[For RHEL]
$ PS1='\e[33;1m\u@\h: \e[31m\w\e[0m\$'

You can restart the shell with the command:
$ exec bash

If you want to try this in practice, login to
the LSF 10 cluster on DTU, and change the PS1
variable, in the .bashrc file.

╔==============================================╗
║         Adding environment variables         ║
╚==============================================╝
You can make working with the shell more
efficient and effective, by making changes to
the .bashrc file.
This can be done by altering or defining the
variables.

[TMOUT]
This variable determine how how long the shell
can be inactive before bash automatically exits.
The value is defined in seconds, and it is a
nice security feature, in case you leave the
desk while still logged into Linux.
To close the shell after a set number of seconds
set the TMOUT value to the desired amount of
time. Example TMOUT=1800 means 30 minutes.

[PATH]
the PATH variable sets the directories that are
searched for, for the commands that you use.
If you often use directories of commands that
are not in your path, you can permanently add
them. To do this, add a PATH variable to your
.bashrc file. For example, to add a directory
called /herpderp/bin, add the following:

PATH=$PATH:/herpderp/bin ; export PATH

This example first reads all of the current
path directories into the new PATH ($PATH),
adds the /herpderp/bin directory, and then
exports the new PATH.

[User defined]
You can create your own environment variables
to provide shortcuts in your work. Choose any
name that is not being used and assign a useful
value to it. For example, if you do lots of
work with files in the /workspace/project1
directory, you could set the following variable:

DERP=/mnt/c/Users/Computer/workspace/project1 ; export DERP

You could make that your current directory with
the command:
$ cd $DERP
You could run a program from that directory
called derpina with the command:
$ .$DERP/derpina
You could edit a file from there called troll
with the command:
$ vi $DERP/troll

The 'export' command is a built-in command of
the Bash shell. It is used to mark variables and
functions to be passed to child processes.

╔==============================================╗
║                  Job control                 ║
╚==============================================╝
When running jobs, you sometimes want the
process running, but still require access to
the console.
That's where the concept of background and
foreground comes into the picture.
On top of that, it's possible to disown a
process, so that it'll continue running, even if
the console is closed.

Foreground jobs are ones that don’t return you
to the command prompt until you exit out of the
job or the job finishes. (example htop)
Background refers to jobs that aren't actively
displayed in the console window, but can be
viewed with the command 'jobs'.

These jobs can be 'running' or 'stopped'.
Background jobs with status 'running' run
exactly  the as if it were in the foreground,
except that it does not receive user input, and
output is still processed accordingly.
Be aware that background processes can still
output something, despite running in the
background, so you can redraw the screen
with [CTRL + L].
The status 'stopped' is considered hibernation.
They do not receive user input, and do not
produce an output.
They don't do anything, and will continue
not doing anything until they're resumed or
killed.

To see a list of processes running in the
background use the command 'jobs'.
To access specific jobs, use the '%'
percentage sign, followed by the number.

Accessing background jobs:                       Description
------------------------------------------------|---------------
%JOB_SPEC                                       : Refers to a specific job.
%                                               : Refers to the most recent command put into the background
                                                  (indicated by the plus sign when you type the jobs command).
                                                  This action brings the command to the foreground
%string                                         : Refers to a job where the command begins with a particular
                                                  string of characters. The string must be unambiguous. (there
                                                  mustn't be multiple commands starting wit the same string)
%?string                                        : Refers to a job where the command line contains a string at
                                                  any point. The string must be unambiguous or the match fails.
%--                                             : Refers to the job stopped before the one most recently stopped

There  are 2 primary ways (that I know of) to
send jobs to the background, notice how one
grants the 'running' status, and the other
provides the 'stopped' status.

Add an ampersand '&' at the end of a command    : Automatically sends the process to the background when the process is created,
                                                  and then display 2 numbers, first  number is the JOB_SPEC, the second number
                                                  is the Processor ID (PID). Setting the status to 'running'.
[CTRL + Z]                                      : Send a SIGTSTP signal, forcing the job to the background
                                                  Setting the status to 'stopped'

The command 'bg' is used to alter the status of
of a background job, from stopped to 'running'.
'fg' is used, to bring a background process
to the foreground.
Use the commands 'fg' and 'bg' to manage/access
the processes, and commands like 'kill' or
'disown' to  terminate and/or let programs
continue to run, even if you close the console.
Remember to use %JOB_SPEC to access  the specific
process directly.

Command                                          Description
------------------------------------------------|---------------
jobs                                            : Display background jobs (hint use -l operator to view PID as well as status)
bg                                              : Move jobs to the background.
                                                  Simulates running in the foreground, same as if it had been started with ' &' 
                                                 Place the jobs identified by each JOB_SPEC in the background,
                                                  If JOB_SPEC is not present, the shell's notion of the current job is used.
fg                                              : Brings a job from the background, to the foreground.
                                                  Located with jobspec
kill                                            : Duplicate in document
disown                                          : Disowns background processes in different ways.
                                                  If no JOB_SPEC is used, the command applies to all jobs in the background.
        -h                                      - If background job status is 'Running', ensures that SIGHUP signal is not sent
                                                  to process, when the shell terminates.
        -a                                      - Remove all jobs if JOB_SPEC is not supplied
        -r                                      - Remove only Running jobs

[Example of management]
$ ping google.com
[CTRL + Z]
$ watch free -h & 
$ htop [CTRL + Z]
$ jobs -l
Now we use the command 'bg' to simulate 'htop'
being started with a ' &' at the end of the
command.
$ bg %3
$ jobs -l
Now we can use the command 'fg' to bring a process
to the foreground, kill it or something else.
$ kill -9 %1
$ fg %2
$ [CTRL + C]
$ jobs -l
And for good measure, we clean up the background.
$ disown -a

╔==============================================╗
║                Managing groups               ║
╚==============================================╝
If you're new to Linux, never ever try managing
creating, or working with groups for a very
simple reason.

It can cause your computer to become unbootable

Table 1.6 lists a number of options that can
be used to manage groups.

If you're running a full distribution of Fedora
or RHEL distros, there is a graphical tool
called "Cockpit"
It can be installed like this.
[Example]
$ yum install cockpit -y
$ systemctl enable --now cockpit.socket
Then open the cockpit interface via the web
browser. In the address field, type in:
(hostname:9090)
From there you can manage accounts.

╔==============================================╗
║                Shell scripting               ║
╚==============================================╝
Shell scripting are primarily used for task
automation. It is capable of executing multiple
commands, take input, customizing administrative
tasks and so on.

There are 2 ways to execute shell scripts.
By using the 'bash' command, or running the file
as an executable.

[Example]
$ bash test.sh
$ ./test.sh

This link explains a lot of the syntax involved
https://linuxhint.com/30_bash_script_examples/

The 1st line of a shell script should be:
#!/bin/bash

It's possible to create variables. Variable
names are case sensitive. 
Variables can contain a number of things such as
numeric, strings, output of functions, and so on.
To create them, there must NOT be a space between
the variable name, and the content. For
functions, use a dollar sign, then parenthesis.
A single hashtag (#) is used as a single line
comment.

[Examples]
VAR1=6465.7270
VAR2="derp"
VAR3=$(date)

Some characters have special meaning in the shell

Special meaning                                  Description
------------------------------------------------|---------------
'enclosedwithin'                                : ' ', literal translation of content within brackets
\followingcharacter                             : Backslash, literal translation of the following character
"STRING"                                        : Content within "" is parsed as a string, variables are
                                                  still considered as such.
$STRING                                         : Name of a variable.

Commonly used parameter expansions in bash
shell scripting:                                 Description
------------------------------------------------|---------------
${var:-value}                                   : If variable is unset or empty expand this to value.
${var#pattern}                                  : Chop the shortest match for pattern from the front of var's value.
${var##pattern}                                 : Chop the longest match for pattern from the front of var's value.
${var%pattern}                                  : Chop the shortest match for pattern from the end of var's value.
${var%%pattern}                                 : Chop the longest match for pattern from the end of var's value.

[Examples]                                       Try these to see the output.
------------------------------------------------|---------------
$ THIS="This is an example"
$ THIS=${THIS:-"Not set"}
$ THAT=${THAT:-"Not set"}
$ echo $THIS
This is an example
$ echo $THAT
Not set

Syntax for 'if', 'else if', 'then', 'then', can
be setup using this format:
if  [argument] ; then                           : If argument is true, then do....
...
elif [argument]                                 : 'Else if'-statement
...
else                                            : 'Else'-statement
...
fi                                              : indicates the end of the 'if'-statement.

[Example]                                       : Operators found in table 1.7
filename="$HOME"
if [ -f "$filename" ] ; then
   echo "$filename is a regular file"
elif [ -d "$filename" ]
   echo "$filename is a directory"
else
   echo "No clue what $filename is."
fi

There is also a shorthand method for an 
if-statement with a single command.
[statement] || [command]                        : If statement fails run [command]
[statement] && [command]                        : If statement succeed run [command]

The 'case' command, otherwise known as a switch,
')' is used for different cases, and '*)' is
used as a default (catchall) case.
'|' is used as an 'OR' bitwise operator.
'esac' is used to end the switch.
The argument can be a number of things including
but not limited to {variable, command, string}
Syntax is:
case [argument] in
';;' is used to end each case.

--------------------[Example]-------------------
# Here we're using the date command 'day' output.
#!/bin/bash
case $(date +%a) in
    "Mon" | "Wed")
        echo "Day is uneven"
        ;;
    "Tue" | "Thu")
        echo "Day is even"
        ;;
    "Fri")
        echo "Almost weekend"
        ;;
    *)
        echo "Either it's weekend, or I screwed up"
        ;;
esac
----------------------[END]---------------------

Loop types.
There are 3 loop types 'for', 'while', 'until'.
Syntax are:

for [variable] in [LIST]
do
   ...
done

while [condition]
do
   ...
done

until [condition]
do
   ...
done

It is possible to disable shell functions,
variables and references with 'unset'.

Command-mode                                     Description
------------------------------------------------|---------------
unset [-f] [-v] [-n] [name ...]                 : Unset a function
        -f                                      - Treat each NAME as a shell function
        -v                                      - Treat each NAME as a shell variable
        -n                                      - Treat each NAME as a name reference and unset the variable itself
                                                  rather than the variable it references

Common Commands                                  Description
------------------------------------------------|---------------
read [VARIABLE]                                 : 
        -p "string containing a prompt"         : 
echo



╔==============================================╗
║                 System calls                 ║
╚==============================================╝
In order to function, most user level commands
and services require access to operations that
are only processed at kernel level.
An example of these kernel operations would be:
Creating processes, network and file IO,
hardware access, and more.

'System calls' are the intermediate point
that allow programs to request limited access
to the kernel.
Essentially an API to allow low level, and user
level programs and services, access to the
kernel.

The specific implementation varies somewhat
<based on cpu architecture and OS, but for now
assume it is all combined within wrapper
functions, such as those supplied by glibc on   : C library, https://en.wikipedia.org/wiki/Glibc
Linux. This allow a higher abstraction level.

Services Provided by System Calls:
•    Process creation and management
•    Main memory management
•    File Access, Directory and File system
     management
•    Device handling(I/O)
•    Protection
•    Networking, etc.

For Linux, the most common system calls are:
open, close, fork, wait, read, write, pipe,
kill, exit, exec.
In order to understand what these mean, I'll
provide a brief explanation for each of these.

Most of these aren't just C-functions, or
commands on a command line.
Look at the manual page for each of these, and
see the category they belong to.

System call                                      Description
------------------------------------------------|---------------
open                                            : open, openat, creat - Open and possibly create a file
close                                           : Close a file descriptor
                                                - File descriptor is integer that uniquely identifies an open file of
                                                  the process.
fork                                            : Create a child process.
                                                  The child process is almost identical to the calling process, the 'fork'
                                                  function return
                                                  a PID, which is set to 0 in the child, but for the parent it is the PID of
                                                  the child. If it returns -1, it means that no child was created.
wait                                            : Wait for process to change state.
                                                  This is specifically used, to reap child processes who becomes zombies.
                                                  When a child process end, rather than dying and releasing all data, it turn
                                                  into a zombie, where associated data is released, but the PID still remain,
                                                  and is tied to the child.
                                                  Using kill on a zombie won't remove it, and there is a limited amount of PID
                                                  available on a Linux OS, which is why it is imperative for programs to reap
                                                  their zombie children.
read                                            : Read from a file descriptor
                                                  Note that this specific name, is also used in shell scripting, when reading
                                                  from the console, and that 2 usefull operators are '-p' for prompt, and '-s'
                                                  for secret.
write                                           : Send a message to another user
pipe                                            : Create a pipe, a unidirectional data channel that can be used for interprocess
                                                  communication. 
exec                                            : Execute a file.
                                                - The whole exec family (execl, execlp, execle, execv, execvp, execvpe) of
                                                  commands, turns the executing program into a zombie, which is why you need to
                                                  create a child, who can execute the command, without affecting the parent.
kill                                            : Send a signal to a process. This is a command.
exit                                            : Cause normal process elimination.


There are 5 types of system calls.
•   Process control: end, abort, create,
                     terminate, allocate
                     and free memory.
•   File management: create, open, close,
                     delete, read file etc.
•   Device management
•   Information maintenance
•   Communication

Now knowing all of this, when you execute a
command, a lot of stuff is happening under the
hood that you aren't aware of, including quite
a few system calls.

In order to test this for yourself, there are a
number of commands, and manual pages you can
read.

Commands                                         Manual description
------------------------------------------------|---------------
syscall                                         : Indirect system call
syscalls                                        : Linux system calls
strace                                          : Trace system calls and signals
ltrace                                          : A library call tracer
ptrace                                          : Process trace
ftrace                                          : Runs the frysk systemcall tracing utility.
                                                - Something about a similar manner to strace, and based on RHEL, rather than DEB.
truss                                           : Trace system calls and signals

[Example]
$ strace ls -la */                              : Display system calls, made during the 'ls' command.
$ ltrace -S ls -la */                           : Also display system and library calls, made during the 'ls' command.

To give you a sense of the scale, there are:    : Source https://en.wikipedia.org/wiki/System_call
More than 300 system calls on Linux,
NetBSD has close to 500,
FreeBSD has over 500,
Windows has close to 2000, (divided between
        win32k (graphical) and ntdll (core)
        system calls).
'Plan 9' has 51.
No details about Mac.

╔==============================================╗
║               Common knowledge               ║
╚==============================================╝
Some common programs or tools on Linux, used for
specific purposes.


Server types
------------------------------------------------|---------------
Name                                            : Bind, dnsmasq, djbdns
Mail                                            : postfix, qmail, sendmail
file                                            : ftp, NFS, Samba, CVS, Subversion, Git
DHCP                                            : With or without DDNS
Database                                        : PostgreSQL, MySQL
Print                                           : CUPS, lpd
CMS                                             : Drupal, Joomla, WordPress)
Web                                             : NginX, Lighthttpd, Tomcat, Apache)
Other                                           : Wiki, SSL, PHP, VoIP, VPN
PXE Boot                                        : PXE boot 


Software Category                                Common programs
------------------------------------------------|---------------
Desktop (GUI)                                   : KDE, Cinnamon, Unity or GNOME desktop
                                                - Graphical access to “cryptic” system functions
                                                - Easy access to dvd/cdrom/USB stick, the print system
Browsing                                        - Firefox, Opera, Chrome
Mail                                            : Thunderbird, Kmail, Evolution
Chat                                            : Konversation (IRC); Pidgin (IM)
Office programs                                 : LibreOffice, GNOME Office, KOffice
Image programs                                  : The GIMP (PhotoShop); Digikam (Photo management)
Music                                           : Audacity (editing); Amarok or Banshee (MP3, Ipod) 


╔==============================================╗
║                   nslookup                   ║
╚==============================================╝
'nslookup' is tool to query Internet name
servers interactively.
As far as I can make out, this command syntax is
identical for both cmd and Bash.

Command syntax                                   Description
------------------------------------------------|---------------
nslookup [website]                              : Provides generic information about a website, such as IP and dns
nslookup -[option] [website]                    : Provides information about a websited specified by the option
nslookup [-option] [name | -] [server]
nslookup –option1 –option2 host-to-find simulated-dns-server
                                                : It is possible to supply 0, 1, 2 or more options
                                                  as well as 2 servers, where the 1st will be queried
                                                  and the 2nd is optional.
                                                  If excluded it'll be sent to the default DNS server

Option list                                       Description
------------------------------------------------|---------------
A                                               : Specifies a computer's IP address.
ANY                                             : Specifies a computer's IP address.
CNAME                                           : Specifies a canonical name for an alias.
GID                                             : Specifies a group identifier of a group name.
HINFO                                           : Specifies a computer's CPU and type of operating system.
MB                                              : Specifies a mailbox domain name.
MG                                              : Specifies a mail group member.
MINFO                                           : Specifies mailbox or mail list information.
MR                                              : Specifies the mail rename domain name.
MX                                              : Specifies the mail exchanger.
NS                                              : Specifies a DNS name server for the named zone. (authorative DNS server)
PTR                                             : Specifies a computer name if the query is an IP address; otherwise, specifies
                                                  the pointer to other information.
SOA                                             : Specifies the start-of-authority for a DNS zone.
TXT                                             : Specifies the text information.
UID                                             : Specifies the user identifier.
UINFO                                           : Specifies the user information.
WKS                                             : Describes a well-known service.

Notice that these syntaxes cause an identical,
response,  {"type", "q", "query}
Example:
nslookup -type=mx dtu.dk                        : Identical
nslookup -q=mx dtu.dk                           : Identical
nslookup -query=mx dtu.dk                       : Identical

: ALTERNATE syntax
Type in 'nslookup', and you'll get a '>'
type in:
> set q=[option]
> [website]

:Examples
$ nslookup -type=mx dtu.dk                      : Info about the mail exchange server for DTU
$ nslookup -query=hinfo  -timeout=10 [website]  : Generates a query, using the hinfo option, with timeout 10 to dtu.dk.
$ nslookup dtu.dk google.com                    : Here we send our query to google.com which will query dtu.dk on our behalf
                                                  and then google will provide us with the result.

╔==============================================╗
║                     tmux                     ║
╚==============================================╝
tmux is a Terminal Multiplexer.
It enables a number of terminals to be created,
accessed, and controlled from a single screen.
What makes it powerful is the ability to be
detached from a screen and continue running in
the background, then later reattached.

In combination with it's ability to detach and
reattach, it can allow multiple users on the
same system to access the same shell
concurrently.

Tmux Navigation                                  Description
------------------------------------------------|---------------
[Ctrl + B + ,]                                  : Rename a window
[Ctrl + B] + [%]                                : Split windows vertically
[Ctrl + B + "]                                  : Split windows horizontally
[Ctrl + B + LArrow]                             : Split window left
[Ctrl + B + RArrow]                             : Split window right
[Ctrl + B] + [Arrow keys]                       : Move between panes

[Ctrl + B (window #)]                           : Switch between windows
[Ctrl + B + UArrow]                             : Scroll up
[Ctrl + B + DArrow]                             : Scroll down
Esc                                             : Escape the scrolling mode
exit            j                                : Close a pane/window
logout                                          : Will terminate a session.

[Ctrl + b] + [d]                                : Will disconnect from the session and keep it persistent

In tmux, a session is displayed on screen by a
client and all sessions are managed by a single
server.
The server and each client are separate
processes which communicate through a socket in
/tmp.

Some relevant flags                             
 [-S socket-path]
 [-s target-session]
 [-t target-client]

[Example]
Assume that a user group have already been set
up to include the relevant users.
$ tmux -S /tmp/shareds new -s [sessionname]     : Here '/tmp/shareds' is the path we choose
                                                - [sessionname] can be some arbitrary name such as 'session1'
$ chmod 777 /tmp/shareds                        : As root, fix permissions of folder /tmp/shareds
$ chgrp [groupname] /tmp/shareds                : As root, change group settings for /tmp/shareds
                                                - [groupname] should be the chosen name, such as dragonslayers
Now every user can connect to the tmux session
with the command
$ tmux -S /tmp/shareds attach -t [sessionname]  : Simply replace [sessionname] with the chosen name, i.e. 'session1'
Remember to log out with
[Ctrl + b] + [d]

╔==============================================╗
║                     cron                     ║
╚==============================================╝
Also known as 'cron job', it is a command-line
utility famous as a 'job scheduler'.
It is used to schedule jobs to run periodically
at fixed times, dates, intervals.


File location                                    Description
------------------------------------------------|---------------
/var/log/cron                                   : Log files
/var/cron/tabs                                  :
/var/spool/cron                                 : Configuration files for different users are stored here
/etc/cron.allow                                 : Configuration file that specify which users are allowed to create cron jobs
                                                  one name per line
/etc/cron.deny                                  : Reverse meaning compared to 'allow'


Cron syntax                                      Description
------------------------------------------------|---------------
crontab                                         : Command for using cron jobs.
        -u user                                 : Configuration for a specific user
        -e                                      : View cronjobs for the current user
        -l                                      : Current crontab will be displayed on standard output
        -r                                      : Causes current crontab to be removed

This is the format which you specify both which
commands to use, but also when to use them.
[a] [b] [c] [d] [e] [/directory/command] [output]
 |   |   |   |   └─────────────────────────────>: Minute, range 0 to 59
 |   |   |   └─────────────────────────────────>: Hour, range 0 to 23
 |   |   └─────────────────────────────────────>: Day of Month, 1 to 31
 |   └─────────────────────────────────────────>: Month of the Year, 1 to 12
 └─────────────────────────────────────────────>: Day of the week, 0 to 6 (0 is sunday)

Configuration operator                           Description
------------------------------------------------|---------------
* (Asterisk)                                    : All values
, (Comma)                                       : Specific separate values
- (Dash)                                        : A range of values
/ (Forward slash)                               : Used divide values into steps


[Examples]                                       Description
------------------------------------------------|---------------
* * * * * $home/derpscript.sh                   : Run shell script as cron job every minutes
20 * * * * $home/derpscript.sh                  : Run shell script as cron job every 20 minutes
* 0 * * * $home/derpscript.sh                   : Run shell script as cron job every hour
* 1 6,17,28 * * $home/derpscript.sh             : Run at 1 am, on date 6, 17 and 28 of every month.
* 1 1-7 * 0 ps aux >> $home/log.txt             : Run on at 1 am, on the first Sunday of every month

╔==============================================╗
║                  Table: 1.0                  ║
╚==============================================╝
Abbreviation list.

Word                                             Description
------------------------------------------------|---------------
Bash                                            : The name of a specific shell.
Boot loader                                     : A program that boots the operating system. Example: {GRUB, ISOLINUX}
Command line                                    : A text interpreter with direct access to the Operatins System.
Desktop environment                             : Graphical user interface on top of the operating system
                                                - Only available for fully fledged installations of Linux OS.
                                                - Example: GNOME, DKE, Xfce and Fluxbox
Directory                                       : Folder structure
Distro/distribution                             : Collection of software making up a Linux-based OS.
                                                  There is a detailed explanation within the introduction section.
flash                                           - File Hierarchy Standard, the layout of the file system on Linux.
Filesystem                                      : Method for storing and organizing files.
                                                - Example: ext3, ext4, FAT, XFS, NTFS and Btrfs
Kernel                                          : Controls hardware, and makes the hardware interact with applications
                                                - Example: Linux kernel
Linux                                           : An operating system
PID                                             : Processor ID, it is used to uniquely identify a process.
PPID                                            : Parent Processor ID. When a process is cloned from another process, it becomes
                                                  a child of the other process, but retains the parents PID, in its own PPID variable.
Prompt                                          : A symbol on a display screen indicating that the computer is waiting for input.
                                                  Once the computer has displayed a prompt, it waits for you to enter some
                                                  information.
                                                - Shell prompt, are the characters that appear on the command line on
                                                  the shell, to the left of when you enter commands.
                                                - 'Commmand prompt' is the symbol that appear at the end of the prompt.
                                                - User prompt ($) or root prompt (#),
                                                - 'A prompt' can also be a message, followed by a required input from the user.
Service                                         : Program that runs as a background process
                                                - Example: httpd, nfsd, ntpd, ftpd and named
Shell                                           : Command line interpreter, that interprets the command line inputs
                                                  and instructs the operating system to perform any necessary tasks and commands.
                                                - Example: Bash, tcsh, and zsh
System calls                                    : A way for programs and services to get specific and restricted access to the
                                                  kernel, via predefined commands. For Linux these commands are most often
                                                  {open, read, write, close, wait, exec, fork, exit, kill, exec, pipe} 
X Window system                                 : An open source, cross platform, client-server computer software system that
                                                  provides a GUI in a distributed network environment.
                                                - (client server architecture)

╔==============================================╗
║                  Table: 1.1                  ║
╚==============================================╝
Bash Configuration files.
File                                             Description
------------------------------------------------|---------------
/etc/profile                                    : This sets up user environment information for every user.
                                                - It is executed when you first log in. This file provides
                                                  values for your path in addition to setting environment
                                                  variables for such things as the location of your mailbox
                                                  and the size of your history files. Finally /etc/profile
                                                  gathers shell settings from configuration files in the
                                                  /etc/profile.d directory.
/etc/bashrc                                     : This executes for every user who runs the bash shell each
                                                  time a bash shell is opened. It sets the default prompt
                                                  and may add one or more aliases. Values in this file can
                                                  be overridden by information in each user's ~/.bashrc file.
~/.bash_profile                                 : This is used by each user to enter information that is
                                                  specific to his or her use of the shell. It is executed
                                                  only once (when the user logs in). By default, it sets
                                                  a few environment variables and executes the users's
                                                  .bashrc file. This is a good place to add environment
                                                  variables because, once set, the are inherited by future
                                                  shells.
~/.bashrc                                       : This contains the information that is specific to your bash
                                                  shells. It is read when you log in and also each time you
                                                  open a new bash shell. This is the best location to add
                                                  aliases so that your shell picks them up.
~/.bash_logout                                  : This executes each time you log out. (exit the last bash
                                                  shell)

╔==============================================╗
║                  Table: 1.2                  ║
╚==============================================╝
Characters to add information to bash prompt.
Special character                                Description
------------------------------------------------|---------------
\!                                              : This shows the current command history number. This includes
                                                  all previuos commands stored for your username.
\#                                              : This shows the command number of the current command.
                                                  This includes only the commands for the active shell.
\$                                              : This shows the user prompt ($) or root prompt (#), depending
                                                  on which type of user you are.
\w                                              : This shows only the current working directory base name.
                                                  For example if the current working directory was
                                                  /var/spool/mail, this value simply appears as mail.
\[                                              : This precedes a sequence of nonprinting characters.
                                                  This can be used to add a Terminal control sequence into
                                                  the prompt for such things as changing colors, adding blink
                                                  effects, or making characters bold. (Your Terminal determines
                                                  the exact sequences available)
\]                                              : This follows a sequence of nonprinting characters.
\\                                              : This shows as backslash
\d                                              : This displays the day name, month, and day number of the
                                                  current date, for example, Wed Jul 21
\h                                              : This shows the hostname of the computer running the shell.
\n                                              : This causes a newline to occur.
\nnn                                            : This shows the character that relates to the octal number
                                                  replacing nnn.
\s                                              : This diplays the current shell name. For the bash shell,
                                                  the value would be bash.
\t                                              : This prints the current time in hours, minutes and seconds,
                                                  example 10:30:30
\u                                              : This prints your current username
\w                                              : This displays the full path to the current working directory

╔==============================================╗
║                  Table: 1.3                  ║
╚==============================================╝
Manual page categories, can be viewed in the
manual page for manual.
aka.
$ man man

Number  Type                                     Description
-------|----------------------------------------|---------------
1       User Commands                           : Executable programs or shell commands
                                                  Commands that can be run from the shell by a regular user
                                                  (typically no administrative privilege is needed)
2       System Calls                            : Functions provided by the kernel
                                                  Programming functions used within an application
                                                  to make calls to the kernel
3       C library functions                     : Library calls (functions within program libraries)
                                                  Programming functions that provide interface to specific
                                                  programming libraries (such as those for certain graphical
                                                  interfaces or other libraries that operate in user space)
4       Devices and special files               : Special files (usually found in /dev)
                                                  Filesystem nods that represent hardware devices (such as
                                                  Terminals or CD drives) or software devices (such as
                                                  random number generators)
5       File formats and conventions            : Types of files (such as a graphics or word proessing file)
        e.g. /etc/passwd                          or specific configuration files (such as the passwd or group file)
6       Games                                   : Games available on the system
7       Miscellaneous                           : Including macro packages and conventions, e.g. man(7), groff(7)
                                                  Overviews of topics such as protocols, filesystems, character
                                                  set standards, and so on
8       System administration commands          : Commands that require root or other administrative privileges to use
        - Tools and Daemons
9       Kernel routines                         : Non standard

╔==============================================╗
║                  Table: 1.4                  ║
╚==============================================╝
(Some of) Linux directory information

tl;dr, this format for the file system on Linux
             ╔═══╗
             ║ / ║ <-- Root node
             ╚═╦═╝
    ╔═══════╦══╩════╦════════╦═══════╗
 ╔══╩══╗ ╔══╩══╗ ╔══╩═══╗ ╔══╩══╗ ╔══╩══╗
 ║ bin ║ ║ etc ║ ║ home ║ ║ tmp ║ ║ usr ║
 ╚═════╝ ╚═════╝ ╚═══╦══╝ ╚═════╝ ╚═════╝
              ╔══════╩═════════╗
          ╔═══╩════╗       ╔═══╩══╗
          ║ Tarzan ║       ║ jane ║
          ╚═══╦════╝       ╚═══╦══╝
              ║          ╔═════╩════╗ 
           ╔══╩═══╗   ╔══╩═══╗   ╔══╩═══╗ 
           ║ food ║   ║ work ║   ║ derp ║
           ╚══════╝   ╚══════╝   ╚══════╝
Please note that different distributions include
additional directories, and this is a rough
sketch to illustrate the format.

Directory                                        Description
------------------------------------------------|---------------
/bin                                            : Contains common Linux user commands, such as ls, sort, date and chmod
/boot                                           : Has the bootable Linux kernel, initiam RAM disk, and boot loader
                                                  configuration files (GRUB)
/dev                                            : Contains files representing access points to devices on your system.
                                                  These include terminal devices (tty*), hard disks (hd* or sd*), RAM
                                                  (ram*), and CD-ROM (cd*). Users can access these devices directly
                                                  through these device files; however applications often hide the actual
                                                  device names to end users.
/etc                                            : Contains administrative configuration files. Most fo these files are
                                                  plain-text files that, given the user has proper permission, can be
                                                  edited with any text editor
/home                                           : Contains directories assigned to each regular user with a login account.
                                                  (The root user is an exception, using /root as his or her home directory.)
/media                                          : Provides a standard location for automounting devices (removable media in
                                                  particular). If the medium has a volume name, that name is typically used
                                                  as the mount point. For example, a USB drive with a volume name of myusb
                                                  would be mounted on /media/myusb
/lib                                            : Contains shared libraries needed by applicatiosn in /bin and /sbin to
                                                  boot systems.
/media                                          : Mount points for filesystems on removable media
/mnt                                            : A common mount point for many devices before it was supplanted by the 
                                                  standard /media directory. Some bootable Linux systems still use this
                                                  directory to mount hard disk partitions and remote filesystems.
                                                  Many people still use this directory to temporarily mount local or remote
                                                  filesystems, which are not mounted permanently.
/misc                                           : A directory sometimes used to automount filesystem upon request
/opt                                            : Directory structure available to store add-on application software.
/proc                                           : Contains information about system resources
/root                                           : Represents the root user's home diretory. The home directory for root
                                                  does not reside beneath /home for seurity reasons.
/run                                            : Rendezvous points for running programs (PIDs, sockets, etc)
/sbin                                           : Contains administrative commands and daemon processes, can only be
                                                  accessed by a Super user (such as Root).
/sys                                            : Contains parameters for such things as tuning block storage and managing
                                                  cgroups.
/tmp                                            : Contains temporary files used by applications.
/usr                                            : Contains user documentation, games, graphicalfiles (X11), libraries (lib),
                                                  and a variety of other commands and files that are not needed during the
                                                  boot process. The /usr directory is meant for files that don't change
                                                  after installation (in theory, /usr could be mounted read-only).
/usr/bin                                        : Most commands and executable files
/usr/include                                    : Header files for compiling C programs
/usr/lib                                        : Libraries; also, support files for standard programs
/usr/local                                      : Local software or configuration data; mirrors /usr
/usr/sbin                                       : Less essential commands for administration and repair
/usr/share                                      : Items that might be common to multiple systems
/usr/share/man                                  : On-line manual pages
/usr/src                                        : Source code for nonlocal software (not widely used)
/usr/tmp                                        : More temporary space (preserved between reboots)
/var                                            : Contains directories of data used by various applications. In particular,
                                                  this is where you would place files that you share as an FTP server
                                                  (/var/ftp) or a web server (/var/www). It also contains all system log
                                                  files (/var/log) and spool files in /var/spool (such as mail, cups, and
                                                  news). The /var directory contains directories and files that are meant
                                                  to change often. On server computers, it is common to create the /var
                                                  directory as a separate filesystem, using a filesystem that that can be
                                                  easily expanded.
/var/adm                                        : Varies: logs, setup records, strange administrative bits
/var/log                                        : System log files
/var/run                                        : Same function as /run; now often a symlink
/var/spool                                      : Spooling (that is, storage) directories for printers, mail, etc.
/var/tmp                                        : More temporary space (preserved between reboots)

╔==============================================╗
║                  Table: 1.5                  ║
╚==============================================╝
Signals available in Linux.

Use this command, to see a list of supported
signals on your system:
$ kill -l
Signal          Number                           Description
---------------|--------------------------------|---------------
SIGHUP           1                              : "Signal hang up" Hang-up detected on controlling terminal or death of
                                                  controlling process. If 'disown -h' is used, the SIGHUP is not sent to
                                                  background processes controlled via the shell.
                                                  Same as [CTRL + C]
SIGINT           2                              : Interrupt from keyboard.
                                                  Same as [CTRL + D]
SIGQUIT          3                              : Quit from keyboard.
SIGILL           4                              : 
SIGTRAP          5                              :
SIGABRT          6                              : Abort signal from abort(3)
SIGBUS           7                              : 
SIGFPE           8                              : 
SIGKILL          9                              : Kill signal.
SIGUSR1         10                              : 
SIGSEGV         11                              : 
SIGUSR2         12                              :
SIGPIPE         13                              : 
SIGALRM            14                              : 
SIGTERM         15                              : Termination signal
SIGSTKFLT       16                              : 
SIGSTOP         17,(19,23)                      : The SIGSTOP signal stops the process. It cannot be handled,
                                                  ignored, or blocked. (suspend the process)
SIGCONT         18,(19,25)                      : Continue if stopped
SIGSTOP         19                              : 
SIGTSTP         20                              : An interactive stop signal. Unlike SIGSTOP, this signal can
                                                  be handled and ignored.
                                                  Same as [CTRL + Z]
SIGTTIN         21                              : 
SIGTTOU         22                              :
SIGURG          23                              :
SIGXCPU         24                              :
SIGXFSZ         25                              :
SIGVTALRM       26                              :
SIGPROF         27                              :
SIGWINCH        28                              :
SIGIO           29                              :
SIGPWR          30                              :
SIGSYS          31                              :
SIGRTMIN        34                              :
SIGRTMIN+1      35                              :
SIGRTMIN+2      36                              :
SIGRTMIN+3      37                              :
SIGRTMIN+4      38                              :
SIGRTMIN+5      39                              :
SIGRTMIN+6      40                              :
SIGRTMIN+7      41                              :
SIGRTMIN+8      42                              :
SIGRTMIN+9      43                              :
SIGRTMIN+10     44                              :
SIGRTMIN+11     45                              :
SIGRTMIN+12     46                              :
SIGRTMIN+13     47                              :
SIGRTMIN+14     48                              :
SIGRTMIN+15     49                              :
SIGRTMAX-14     50                              :
SIGRTMAX-13     51                              :
SIGRTMAX-12     52                              :
SIGRTMAX-11     53                              :
SIGRTMAX-10     54                              :
SIGRTMAX-9      55                              :
SIGRTMAX-8      56                              :
SIGRTMAX-7      57                              :
SIGRTMAX-6      58                              :
SIGRTMAX-5      59                              :
SIGRTMAX-4      60                              :
SIGRTMAX-3      61                              :
SIGRTMAX-2      62                              :
SIGRTMAX-1      63                              :
SIGRTMAX        64                              :

╔==============================================╗
║                  Table: 1.6                  ║
╚==============================================╝
Control group limiting options.

Topics                                           Description
------------------------------------------------|---------------
Storage (blkio)                                 : Limits total input and output access to storage devices (such as hard
                                                  disks, USB drives, and so on)
Processor scheduling (cpu)                      : Assigns the amount of access a cgroup has to be scheduled for
                                                  processing power.
Process accounting (cpuacct)                    : Reports on CPU usage. This information can be leveraged to charge
                                                  clients for the amount of processing power they use.
CPU assignment (cpuset)                         : On systems with multiple CPU cores, assigns a task to a particular set
                                                  of processors and assiciated memory.
Device access (devices)                         : Allows tasks in a cgroup to open or create (mknod) selected device
                                                  types.
Suspend/resume (freezer)                        : Suspends and resumes cgroup tasks
Memory usage (memory)                           : Limits memory usage by task. It also creates reports on memory
                                                  resources used.
Network bandwidth (net_cls)                     : Limits network access to selected cgroup tasks. This is done by
                                                  tagging network packets to identify the cgroup task that originated
                                                  the packet and having the Linux traffic controller monitor and restrict
                                                  packets coming from each group.
Network traffic (net_prio)                      : Sets priorities of network traffic coming from selected cgroups and
                                                  lets administrators change these priorites on the fly.
Name spaces (ns)                                : Separates cgroups into namespaces, so processes in one cgroup can only
                                                  see the namespaces associated with the cgroup. Namespaces can include
                                                  separate process tables, mount tables, and network interfaces.

╔==============================================╗
║                  Table: 1.7                  ║
╚==============================================╝
Operators for test expressions(Shell scripting)

Shell scripting if/else statements operators.
These can be found using the bash command:
$ help test
Operator                                         What is being tested
------------------------------------------------|---------------
-a file                                         : Does the file exist?
-b file                                         : Is the file a block special device?
-c file                                         : Is the file character special (For example, a character device)? Used to
                                                  identify serial lines and terminal devices.
-d file                                         : Is the file a directory?
-e file                                         : Does the file exist? (same as -a)
-f file                                         : Does the file exist, and is it a regular file (for example), not a directory,
                                                  socket, pipe, link, or device file?
-g file                                         : Does the file have the set group id (SGID) bit set?
-h file                                         : Is the file a symbolic link? (Same as -L)
-k file                                         : Does the file have the sticky bit set?
-L file                                         : Is the file a symbolic link?
-n string                                       : Is the length of the string greater than 0 bytes?
-O file                                         : Do you own the file?
-p file                                         : Is the file a named pipe?
-r file                                         : Is the file readably by you?
-s file                                         : Does the file exist, and is it larger than 0 bytes?
-S file                                         : Does the file exist, and is it a socket?
-t fd                                           : Is the file descriptor connected to a terminal?
-u file                                         : Does the file have the set user id(SUID) bit set?
-w file                                         : Is the file writable by you?
-x file                                         : Is the file executable by you?
-z string                                       : Is the length of the string 0 (zero) bytes?
expr1 -a expr2                                  : Are both the first expression and the second expression true?
expr1 -o expr2                                  : Is either of the two expressions true?
file1 -nt file2                                 : Is the first file newer than the second file (using the modification time
                                                  stamp)?
file1 -ot file2                                 : Is the first file older than the second file (using the modification time
                                                  stamp)?
file1 -ef file2                                 : Are the two files associated by a link (a hard link or a symbolic link)?
var1 = var2                                     : Is the first variable equal to the second variable?
var1 -eq var2                                   : Is the first variable equal to the second variable?
var1 -ge var2                                   : Is the first variable greater than or equal to the second variable?
var1 -gt var2                                   : Is the first variable greater than the second variable?
var1 -le var2                                   : Is the first variable less than the second variable?
var1 -lt var2                                   : Is the first variable not equal to the second variable?
var1 != var2                                    : Is the first variable not equal to the second variable?
var1 -ne var2                                   : Is the firat variable not equal to the second variable?

A lot of additional operators for commands can
be found in the manual for bash.
$ man bash
Example:
read operators                                   Description
------------------------------------------------|---------------
-a                                              : aname
                                                - The words are assigned to sequential indices of the array variable aname,
                                                  starting at 0.  aname is unset before any new values are assigned.
                                                  Other name arguments are ignored.
-d                                              : delim
                                                - The first character of delim is used to terminate the input line, rather than
                                                  newline. If delim is the empty string, read will terminate a line when it reads
                                                  a NULL character.
-e                                              : If the standard input is coming from a terminal, readline (see READLINE) is
                                                  used to obtain the line. Readline uses the current (or default, if line editing
                                                  was  not  previously active) editing settings, but uses Readline's
                                                  default filename completion.
-i                                              : text
                                                - If readline is being used to read the line, text is placed into the editing
                                                  buffer before editing begins.
-n                                              : nchars
                                                - read  returns  after  reading nchars characters rather than waiting for a
                                                  complete line of input, but honors a delimiter if fewer than nchars characters
                                                  are read before the delimiter.
-N                                              : nchars
                                                - read returns after reading exactly nchars characters rather than waiting for a
                                                  complete line of input, unless EOF is encountered or read times out.
                                                  Delimiter  characters  encountered  in  the  input  are not treated specially
                                                  and do not cause read to return until nchars characters are read.  The result
                                                  is not split on the characters in IFS; the intent is that the variable i
                                                  assigned exactly the characters read (with the exception of backslash; see the
                                                  -r option below).
-p                                              : prompt
                                                - Display prompt on standard error, without a trailing newline, before attempting
                                                  to read any input. The prompt is displayed only if input is coming from a
                                                  terminal.
-r                                              : Backslash does not act as an escape character.  The backslash is considered to
                                                  be part of the line.  In particular, a backslash-newline pair may not then be
                                                  used as a line continuation.
-s                                              : Silent mode. 
                                                - If input is coming from a terminal, characters are not echoed.
-t                                              : timeout
                                                - Cause  read  to  time out and return failure if a complete line of input (or a
                                                  specified number of characters) is not read within timeout seconds.  timeout
                                                  maybe a decimal number with a fractional portion following the decimal point.
                                                  This option is only effective if read is reading input from a terminal, pipe,
                                                  or other special file; it has no effect  when reading  from  regular files.
                                                  If read times out, read saves any partial input read into the specified
                                                  variable name.  If timeout is 0, read returns immediately, without trying to
                                                  read any data.  The exit status is 0 if input is available on the specified
                                                  file descriptor, non-zero otherwise.  The exit status is greater than 128 if
                                                  the timeout is exceeded.
-u                                              : File descriptor (fd)
                                                - Read input from file descriptor fd.

╔==============================================╗
║                  Table: 1.8                  ║
╚==============================================╝
Everything in Linux is a file, from logging in 
to the commands you use.

Here is an overview for some of the files that
are of interest for some reason or another.
As well as their location

File and location                                Description
------------------------------------------------|---------------
$HOME/.bashrc                                   : This is a shell script that is run whenever a user start a new terminal
                                                  as such, it is a good place to configure your personal shell expericence
                                                  such as prompt, additional aliases, and settings for the terminal
$HOME/.bash_profile                             : This is a configuration file
$HOME/.bash_history                             :
$HOME/.viminfo                                  :

.login ... ?
.logout ... ?
.profile ... /etc/profile
.wm_style ... ?

/boot/vmlinuz                                   : The Linux kernel file.  File naming conventions may include release
                                                  information
/dev/fd0                                        : Device file for the first floppy disk drive on the system
/dev/fd0H1440                                   : Device driver for the first floppy drive in high density mode, commonly invoked
                                                  when formatting a floppy diskette for that density
/dev/hda                                        : Device file for the first IDE hard drive on the system
/dev/hdc                                        : Commonly, the IDE CDROM drive device file which often is a symbolic link called
                                                  to /dev/cdrom, the real CDROM driver file.
/dev/null                                       : A dummy device which contains nothing.  It is sometimes useful to send output
                                                  to this device to make it go away forever.
/etc/aliases                                    : Contains aliases used by sendmail and other mail transport agents. Whenever
                                                  this file is changed, the newaliases utility must be run to notify sendmail of
                                                  the changes
/etc/bashrc                                     : Contains global defaults and aliases used by the bash shell
/etc/crontab                                    : A parent shell script to run commands periodically.  It invokes hourly, daily,
                                                  weekly, and monthly scripts.
/etc/exports                                    : Contains a list of filesystems which may be made available to other systems on
                                                  the network via NFS.
/etc/fstab                                      : The file system table contains the description of what disk devices are
                                                  available at what mount points.
/etc/group                                      : Holds information regarding security group definitions.
/etc/grub.conf                                  : The grub boot loader configuration file
/etc/hosts                                      : Contains host names and their corresponding IP addresses used for name
                                                  resolution whenever a DNS server is unavailable
/etc/hosts.allow                                : Contains a list of hosts allowed to access services on this computer.
/etc/hosts.deny                                 : Contains a list of hosts forbidden to access services on this computer.
/etc/inittab                                    : Describes how the INIT process should set up the system in various runlevels
/etc/issue                                      : Contains the pre-login message, often overwritten by the /etc/rc.d/rc.local
                                                  script in Red Hat and some other rpm-based Linux distributions
/etc/lilo.conf                                  : The lilo boot loader configuration file
/etc/modules.conf                               : Holds options for configurable system modules
/etc/motd                                       : This is the ?message of the day? file which is printed upon login. It can be
                                                  overwritten by /etc/rc.d/rc.local Red Hat on startup.
/etc/mtab                                       : Status information for currently mounted devices and partitions
/etc/passwd                                     : Contains information regarding registered system users. Passwords are typically
                                                  kept in a shadow file for better security.
/etc/printcap                                   : Holds printer setup information
/etc/profile                                    : Contains global defaults for the bash shell
/etc/resolv.conf                                : A list of domain name servers (DNS) used by the local machine
/etc/securetty                                  : This file contains a list of terminals where root can login
/etc/shadow                                     : Here the hashed passwords are stored
/etc/termcap                                    : An extensive ASCII text file defining the properties of consoles, terminals,
                                                  and printers
/proc/cpuinfo                                   : Contains CPU related information
/proc/filesystems                               : Holds information regarding filesystems that are currently in use
/proc/interrupts                                : Stores the interrupts that are currently being used
/proc/ioports                                   : A list of the I/O addresses used by devices connected to the server
/proc/meminfo                                   : Contains memory usage information for both physical memory and swap
/proc/modules                                   : Lists currently loaded kernel modules
/proc/mounts                                    : Displays currently mounted file systems
/proc/stat                                      : Contains various statistics about the system, such as the number of page faults
                                                  since the system was last booted
/proc/swaps                                     : Holds swap file utilization information
/proc/version                                   : Contains Linux version information
/var/log/lastlog                                : Stores information about the last boot process
/var/log/messages                               : Contains messages produced by the syslog daemon during the boot process
/var/log/wtmp                                   : A binary data file holding login time and duration for each user currently on
                                                  the system
╔==============================================╗
║                  References                  ║
╚==============================================╝
http://www.tlpd.org/HOWTO/Bash-Prompt-HOWTO     : Refer to this link for information on changing colors, commands and other
                                                  features of your bash shell prompt
https://chrisjean.com/multitasking-from-the-linux-command-line-plus-process-prioritization/
                                                : Background, foreground, job priority
https://linuxhint.com/30_bash_script_examples/  : Bash scripting
https://github.com/vossenjp/bashcookbook-examples
                                                : Github repository of some shell scripts (although a lot of them are poorly
                                                  explained)
https://opensource.com/article/19/10/strace     : Understanding System calls
https://en.wikipedia.org/wiki/System_call       : System calls
https://www.geeksforgeeks.org/introduction-of-system-call/
                                                : System calls
- http://www.dba-oracle.com/linux/important_files_directories.htm
                                                : Important files
- https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.txt
                                                : Another manual for the bash, not concise at all, but there are very relevant
                                                  topics, even if they're poorly described